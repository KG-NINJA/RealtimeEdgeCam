<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>A-1 Robot Vision - Smooth Control</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<style>
* { box-sizing: border-box; }
body { 
  margin: 0; padding: 0; 
  background: #000; color: #0f0; 
  font-family: 'Courier New', monospace; 
  font-size: 14px; 
  overflow: hidden; 
  width: 100vw; height: 100vh;
  touch-action: manipulation;
}

/* PC / ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆ */
@media (min-width: 768px) {
  #camera-feed { 
    position: absolute; top: 0; left: 0; 
    width: 100%; height: 100%; 
    z-index: 1; 
  }
  #cv { display: block; width: 100%; height: 100%; }
  
  #ui { 
    position: fixed; top: 15px; left: 15px; 
    background: rgba(0, 0, 0, 0.95); 
    padding: 15px; 
    border: 2px solid #0f0; 
    z-index: 100;
    min-width: 280px;
    max-height: 500px;
    overflow-y: auto;
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
  }
  
  .robot-sim { 
    position: fixed; 
    bottom: 15px; right: 15px; 
    border: 3px solid #0f0; 
    background: rgba(0, 15, 0, 0.95); 
    z-index: 50;
    width: 280px;
    height: 280px;
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
  }
  
  #steer-gauge {
    position: fixed;
    top: 310px;
    left: 15px;
    width: 280px;
    height: 40px;
    z-index: 50;
  }
  
  #keys-info {
    position: fixed;
    bottom: 15px;
    left: 15px;
    background: rgba(0, 0, 0, 0.95);
    border: 2px solid #0f0;
    padding: 10px;
    font-size: 11px;
    z-index: 49;
    max-width: 280px;
    display: block;
  }
}

/* ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ */
@media (max-width: 767px) {
  body { font-size: 12px; }
  
  #camera-feed { 
    position: absolute; top: 0; left: 0; 
    width: 100%; height: 60%; 
    z-index: 1; 
  }
  #cv { display: block; width: 100%; height: 100%; }
  
  #ui { 
    position: fixed; 
    top: 60%; left: 0; right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.98); 
    padding: 10px; 
    border-top: 2px solid #0f0;
    z-index: 100;
    overflow-y: auto;
    max-height: 40vh;
  }
  
  .status-line { 
    margin: 4px 0; 
    padding: 3px 0;
    font-size: 12px;
  }
  
  .value { 
    min-width: 60px;
    font-size: 12px;
  }
  
  .robot-sim { 
    position: fixed; 
    top: 60%; right: 0;
    width: 160px;
    height: 160px;
    border: 2px solid #0f0; 
    background: rgba(0, 15, 0, 0.95); 
    z-index: 50;
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
  }
  
  #steer-gauge {
    position: fixed;
    top: 60%;
    left: 0;
    right: 160px;
    height: 60px;
    z-index: 50;
  }
  
  #keys-info {
    display: none; /* ã‚¹ãƒãƒ›ã§ã¯éè¡¨ç¤º */
  }
  
  /* ã‚¿ãƒƒãƒãƒœã‚¿ãƒ³ */
  #touch-controls {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 60px;
    background: rgba(0, 0, 0, 0.95);
    border-top: 1px solid #0f0;
    display: flex;
    z-index: 101;
  }
  
  .touch-btn {
    flex: 1;
    border: 1px solid #0f0;
    background: rgba(0, 30, 0, 0.8);
    color: #0f0;
    font-weight: bold;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    transition: all 0.1s;
  }
  
  .touch-btn:active {
    background: rgba(0, 255, 0, 0.3);
    box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.5);
  }
  
  .touch-btn:hover {
    background: rgba(0, 50, 0, 0.9);
  }
}

.status-line { 
  margin: 8px 0; 
  padding: 5px 0;
  border-bottom: 1px solid #033; 
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.label { flex: 1; }
.value { 
  font-weight: bold; 
  padding: 0 8px;
  text-align: right;
}
#video { position: fixed; left: -10000px; opacity: 0; }
</style>
</head>
<body>

<div id="camera-feed"><canvas id="cv"></canvas></div>

<div id="ui">
  <div style="margin-bottom: 10px; font-weight: bold; font-size: 16px; text-shadow: 0 0 10px #0f0;">
    âš™ï¸ A-1 ROBOT VISION
  </div>
  <div class="status-line">
    <span class="label">ğŸ¯ éšœå®³ç‰©è·é›¢</span>
    <span class="value" id="obs-score">100</span>
  </div>
  <div class="status-line">
    <span class="label">ğŸ§  Gemmaæ€è€ƒ</span>
    <span class="value" id="gemma-status">å¾…æ©Ÿä¸­</span>
  </div>
  <div class="status-line">
    <span class="label">ğŸ¤– ãƒ­ãƒœãƒƒãƒˆçŠ¶æ…‹</span>
    <span class="value" id="robot-mode" style="color:#f00">åœæ­¢ä¸­</span>
  </div>
  <div class="status-line">
    <span class="label">ğŸ“ ç¾åœ¨ã®æŒ‡ç¤º</span>
    <span class="value" id="last-decision">-</span>
  </div>
  <div class="status-line">
    <span class="label">âš¡ é€Ÿåº¦</span>
    <span class="value" id="speed-display">0.0</span>
  </div>
  <div class="status-line">
    <span class="label">ğŸ¯ ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°</span>
    <span class="value" id="steer-display">â†’ ä¸­ç«‹</span>
  </div>
</div>

<div style="position: fixed; top: 310px; left: 15px; width: 280px; height: 40px; background: rgba(0, 0, 0, 0.95); border: 2px solid #0f0; z-index: 50; box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);">
  <canvas id="steer-gauge" width="280" height="40" style="display: block; width: 100%; height: 100%;"></canvas>
</div>

<div id="keys-info">
  <div style="font-weight: bold; margin-bottom: 5px;">æ“ä½œã‚­ãƒ¼</div>
  <div>M ã‚­ãƒ¼: AIèªè­˜ ON/OFF</div>
  <div>R ã‚­ãƒ¼: ãƒ­ãƒœãƒƒãƒˆå‹•ä½œ ON/OFF</div>
</div>

<canvas id="robot-sim" class="robot-sim" width="280" height="280"></canvas>
<video id="video" autoplay playsinline muted></video>

<!-- ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ç”¨ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
<div id="touch-controls">
  <button class="touch-btn" id="btn-ai">ğŸ§  AI</button>
  <button class="touch-btn" id="btn-robot">ğŸ¤– å‹•ä½œ</button>
  <button class="touch-btn" id="btn-camera">ğŸ“¹</button>
  <button class="touch-btn" id="btn-info">â„¹ï¸</button>
</div>

<script src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
const state = {
  cvReady: false,
  mlReady: false,
  mlEnabled: false,
  mlInFlight: false,
  lastObstacleScore: 100,
  robotEnabled: false,
  
  robotX: 140,
  robotY: 140,
  robotTheta: 0,
  robotVLin: 0,
  robotVAng: 0,
  targetVLin: 0,
  targetVAng: 0,
  
  gemmaLastAction: 'WAITING',
  gemmaNextAt: 0,
  gemmaThinking: false,
  
  // ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°æƒ…å ±
  steerValue: 0,  // -1..+1 (å·¦å±é™º=è² ã€å³å±é™º=æ­£)
  steerNextAt: 0
};

const video = document.getElementById('video');
const cvCanvas = document.getElementById('cv');

async function loadML() {
  if (window.tf && window.cocoSsd) return;
  
  console.log("Loading TensorFlow.js...");
  
  try {
    if (!window.tf) {
      await loadScript("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0");
    }
    if (!window.cocoSsd) {
      await loadScript("https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3");
    }
    state.model = await cocoSsd.load();
    state.mlReady = true;
    document.getElementById('gemma-status').textContent = 'æº–å‚™å®Œäº†';
    console.log("ML Model Ready");
  } catch (e) {
    console.error("ML Load Error:", e);
    document.getElementById('gemma-status').textContent = 'ã‚¨ãƒ©ãƒ¼';
  }
}

function loadScript(src) {
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = src;
    s.onload = resolve;
    s.onerror = reject;
    document.head.appendChild(s);
  });
}

const capCanvas = document.createElement('canvas');
const capCtx = capCanvas.getContext('2d', { willReadFrequently: true });

function runCV() {
  if (!state.cvReady || !video.videoWidth) return;
  
  capCanvas.width = video.videoWidth;
  capCanvas.height = video.videoHeight;
  capCtx.drawImage(video, 0, 0);
  
  let src = cv.matFromImageData(capCtx.getImageData(0, 0, video.videoWidth, video.videoHeight));
  let gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.Canny(gray, gray, 50, 100);
  cv.imshow(cvCanvas, gray);
  
  src.delete();
  gray.delete();
}

async function runML() {
  if (!state.mlEnabled || !state.mlReady || state.mlInFlight) return;
  
  state.mlInFlight = true;
  
  try {
    const preds = await state.model.detect(capCanvas);
    
    if (preds.length > 0) {
      let obj = preds.sort((a, b) => b.score - a.score)[0];
      state.lastObstacleScore = Math.max(5, Math.min(100, Math.round(obj.score * 100)));
    } else {
      state.lastObstacleScore = 100;
    }
    
    document.getElementById('obs-score').textContent = state.lastObstacleScore;
    
  } catch (e) {
    console.error("ML Error:", e);
  } finally {
    state.mlInFlight = false;
  }
}

// ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°è¨ˆç®—ç”¨ã®ãƒ‡ãƒ¼ã‚¿
const steeringGradient = {
  columns: new Float32Array(9),  // 9åˆ†å‰²
  bestSteer: 0  // -1..+1
};

function calculateSteering() {
  // ç°¡æ˜“çš„ãªã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°è¨ˆç®—ï¼šãƒ©ãƒ³ãƒ€ãƒ ãªã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
  // å®Ÿéš›ã®ç”»åƒå‹¾é…ã®ä»£ã‚ã‚Šã«ã€å¹³æ»‘åŒ–ã•ã‚ŒãŸãƒ©ãƒ³ãƒ€ãƒ å€¤ã‚’ä½¿ç”¨
  const now = performance.now();
  
  if (now < state.steerNextAt) return;
  state.steerNextAt = now + 200; // 200ms ã”ã¨ã«æ›´æ–°
  
  // å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«å°ã•ãªãƒ©ãƒ³ãƒ€ãƒ å¤‰å‹•ã‚’åŠ ãˆã‚‹
  let sum = 0;
  for (let i = 0; i < steeringGradient.columns.length; i++) {
    // å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®å€¤ã«å°ã•ãªå¤‰å‹•ã‚’åŠ ãˆã‚‹ï¼ˆå¹³æ»‘åŒ–ï¼‰
    steeringGradient.columns[i] += (Math.random() - 0.5) * 0.3;
    steeringGradient.columns[i] = Math.max(0, Math.min(1, steeringGradient.columns[i]));
    sum += steeringGradient.columns[i];
  }
  
  // æœ€å°å±é™ºæ–¹å‘ã‚’æ¢ã™
  let minIdx = 0;
  let minVal = Infinity;
  for (let i = 0; i < steeringGradient.columns.length; i++) {
    if (steeringGradient.columns[i] < minVal) {
      minVal = steeringGradient.columns[i];
      minIdx = i;
    }
  }
  
  // -1..+1 ã«æ­£è¦åŒ–ï¼ˆä¸­å¤® = 4ï¼‰
  const mid = (steeringGradient.columns.length - 1) / 2;
  state.steerValue = (minIdx - mid) / mid;
  
  // UIæ›´æ–°
  let steerLabel = 'â†’ ä¸­ç«‹';
  if (state.steerValue < -0.3) {
    steerLabel = 'â† å·¦å±é™º';
  } else if (state.steerValue > 0.3) {
    steerLabel = 'å³å±é™º â†’';
  }
  document.getElementById('steer-display').textContent = steerLabel;
}

async function askGemma(now) {
  if (!state.robotEnabled || now < state.gemmaNextAt || state.gemmaThinking) return;
  
  state.gemmaThinking = true;
  state.gemmaNextAt = now + 2500;
  document.getElementById('gemma-status').textContent = 'æ€è€ƒä¸­...';
  
  const distance = state.lastObstacleScore;
  console.log("Distance:", distance);
  
  try {
    const res = await fetch('https://kgninja-functiongemmabotdemo-docker.hf.space/decide', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        front_distance: distance,
        speed: state.robotVLin,
        steer: state.steerValue  // ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°æƒ…å ±ã‚’é€ä¿¡
      })
    });
    
    const json = await res.json();
    console.log("API Response:", json);
    
    let action = null;
    
    if (json.data && json.data[0]) {
      const match = json.data[0].match(/\{.*\}/s);
      if (match) {
        const d = JSON.parse(match[0]);
        action = (d.action || '').toLowerCase();
        console.log("Parsed action:", action);
      }
    }
    
    // APIãŒç„¡åŠ¹ãªå¿œç­”ã®å ´åˆã€è·é›¢ãƒ™ãƒ¼ã‚¹ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    if (!action) {
      console.warn("âš ï¸ API invalid, using fallback logic");
      if (distance < 30) {
        action = Math.random() > 0.5 ? 'turn_left' : 'turn_right';
      } else if (distance < 60) {
        const actions = ['move_forward', 'turn_left', 'turn_right'];
        action = actions[Math.floor(Math.random() * 3)];
      } else {
        action = 'move_forward';
      }
      console.log("Fallback action:", action);
    }
    
    state.gemmaLastAction = action.toUpperCase().replace('_', ' ');
    document.getElementById('last-decision').textContent = state.gemmaLastAction;
    document.getElementById('gemma-status').textContent = 'å®Œäº† âœ“';
    
    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«åŸºã¥ã„ã¦ç›®æ¨™é€Ÿåº¦ã‚’è¨­å®š
    if (action === 'move_forward') {
      state.targetVLin = 0.8;
      state.targetVAng = 0;
      console.log("â†’ FORWARD");
    } else if (action === 'turn_left') {
      state.targetVLin = 0.3;
      state.targetVAng = -2.0;  // å·¦å›è»¢
      console.log("â†’ LEFT");
    } else if (action === 'turn_right') {
      state.targetVLin = 0.3;
      state.targetVAng = 2.0;   // å³å›è»¢
      console.log("â†’ RIGHT");
    } else {
      state.targetVLin = 0;
      state.targetVAng = 0;
      console.log("â†’ STOP");
    }
    
  } catch (e) {
    console.error("Gemma API Error:", e);
    document.getElementById('gemma-status').textContent = 'APIå¤±æ•—';
    state.targetVLin = 0;
    state.targetVAng = 0;
  } finally {
    state.gemmaThinking = false;
  }
}

function animate(now) {
  if (!state.cvReady && video.videoWidth > 0) {
    cvCanvas.width = 320;
    cvCanvas.height = 240;
    state.cvReady = true;
  }
  
  runCV();
  runML();
  calculateSteering();  // ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°è¨ˆç®—ã‚’è¿½åŠ 
  
  if (state.mlEnabled) {
    askGemma(now);
  }
  
  if (state.robotEnabled) {
    state.robotVLin += (state.targetVLin - state.robotVLin) * 0.15;
    state.robotVAng += (state.targetVAng - state.robotVAng) * 0.15;
    
    state.robotTheta += state.robotVAng * 0.016;
    state.robotX += Math.cos(state.robotTheta) * state.robotVLin * 3;
    state.robotY += Math.sin(state.robotTheta) * state.robotVLin * 3;
    
    state.robotX = Math.max(15, Math.min(265, state.robotX));
    state.robotY = Math.max(15, Math.min(265, state.robotY));
  }
  
  document.getElementById('speed-display').textContent = state.robotVLin.toFixed(2);
  
  drawSimulator();
  drawSteeringGauge();
  
  requestAnimationFrame(animate);
}

function drawSteeringGauge() {
  const canvas = document.getElementById('steer-gauge');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;
  
  // èƒŒæ™¯
  ctx.fillStyle = 'rgba(0, 15, 0, 0.95)';
  ctx.fillRect(0, 0, w, h);
  
  // ã‚°ãƒªãƒƒãƒ‰ãƒ©ã‚¤ãƒ³ã¨å±é™ºåº¦ãƒãƒ¼
  const sections = 9;
  const secWidth = w / sections;
  
  for (let i = 0; i < sections; i++) {
    const x = i * secWidth;
    
    // ã‚»ã‚¯ã‚·ãƒ§ãƒ³èƒŒæ™¯
    const hazardLevel = steeringGradient.columns[i];
    const a = 0.15 + 0.65 * hazardLevel;
    ctx.fillStyle = `rgba(255, 255, 255, ${a})`;
    ctx.fillRect(x + 1, 4, secWidth - 2, h - 8);
    
    // ã‚»ã‚¯ã‚·ãƒ§ãƒ³å¢ƒç•Œç·š
    ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x + 0.5, 2);
    ctx.lineTo(x + 0.5, h - 2);
    ctx.stroke();
  }
  
  // å®‰å…¨ãªæ–¹å‘ã‚’ç¤ºã™ç™½ã„æŒ‡æ¨™ç·š
  const steerX = ((state.steerValue + 1) / 2) * w;
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(steerX, 2);
  ctx.lineTo(steerX, h - 2);
  ctx.stroke();
  
  // ãƒ©ãƒ™ãƒ«
  ctx.font = '10px monospace';
  ctx.fillStyle = '#0f0';
  ctx.textAlign = 'left';
  ctx.fillText('å·¦', 5, 14);
  ctx.textAlign = 'right';
  ctx.fillText('å³', w - 5, 14);
  ctx.textAlign = 'center';
  ctx.fillText('å±é™ºåº¦ãƒãƒƒãƒ—', w / 2, 14);
}

function drawSimulator() {
  const canvas = document.getElementById('robot-sim');
  const ctx = canvas.getContext('2d');
  
  ctx.fillStyle = 'rgba(0, 15, 0, 0.95)';
  ctx.fillRect(0, 0, 280, 280);
  
  ctx.strokeStyle = 'rgba(0, 255, 0, 0.1)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 280; i += 28) {
    ctx.beginPath();
    ctx.moveTo(i, 0);
    ctx.lineTo(i, 280);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, i);
    ctx.lineTo(280, i);
    ctx.stroke();
  }
  
  ctx.font = 'bold 16px monospace';
  ctx.fillStyle = '#0f0';
  ctx.fillText('AI: ' + state.gemmaLastAction, 15, 30);
  
  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fillRect(15, 45, 100, 20);
  ctx.strokeStyle = '#0f0';
  ctx.strokeRect(15, 45, 100, 20);
  
  const fillWidth = (state.lastObstacleScore / 100) * 100;
  ctx.fillStyle = state.lastObstacleScore > 50 ? '#0f0' : state.lastObstacleScore > 20 ? '#ff0' : '#f00';
  ctx.fillRect(15, 45, fillWidth, 20);
  
  ctx.font = '11px monospace';
  ctx.fillStyle = '#0f0';
  ctx.fillText('è·é›¢: ' + state.lastObstacleScore, 20, 58);
  
  ctx.save();
  ctx.translate(state.robotX, state.robotY);
  ctx.rotate(state.robotTheta);
  
  ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
  ctx.beginPath();
  ctx.arc(0, 0, 12, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  ctx.fillStyle = '#0f0';
  ctx.beginPath();
  ctx.moveTo(0, -12);
  ctx.lineTo(-6, 6);
  ctx.lineTo(6, 6);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
  
  ctx.font = '10px monospace';
  ctx.fillStyle = 'rgba(0, 255, 0, 0.6)';
  ctx.fillText('é€Ÿåº¦: ' + state.robotVLin.toFixed(2), 15, 270);
  ctx.fillText('è§’é€Ÿåº¦: ' + state.robotVAng.toFixed(1), 120, 270);
  
  if (!state.robotEnabled) {
    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
    ctx.font = 'bold 20px monospace';
    ctx.fillText('STOPPED', 70, 140);
  }
}

window.addEventListener('keydown', e => {
  if (e.code === 'KeyM') {
    state.mlEnabled = !state.mlEnabled;
    if (state.mlEnabled) {
      loadML();
      document.getElementById('gemma-status').textContent = 'èª­ã¿è¾¼ã¿ä¸­...';
    } else {
      document.getElementById('gemma-status').textContent = 'ç„¡åŠ¹';
      document.getElementById('last-decision').textContent = '-';
    }
  }
  
  if (e.code === 'KeyR') {
    state.robotEnabled = !state.robotEnabled;
    const modeEl = document.getElementById('robot-mode');
    modeEl.textContent = state.robotEnabled ? 'ç¨¼åƒä¸­' : 'åœæ­¢ä¸­';
    modeEl.style.color = state.robotEnabled ? '#0f0' : '#f00';
    
    if (!state.robotEnabled) {
      state.targetVLin = 0;
      state.targetVAng = 0;
      state.robotVLin = 0;
      state.robotVAng = 0;
    }
  }
});

cv['onRuntimeInitialized'] = () => {
  navigator.mediaDevices.getUserMedia({ video: true }).then(s => {
    video.srcObject = s;
    video.play();
    requestAnimationFrame(animate);
    console.log("System Ready - Press M to enable AI, R to enable Robot");
  });
};
</script>

</body>
</html>
