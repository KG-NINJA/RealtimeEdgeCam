<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>A-1 Robot Vision + Gemma Control</title>
<style>
* { box-sizing: border-box; }

body {
  margin: 0;
  padding: 0;
  background: #000;
  color: #0f0;
  font-family: monospace;
  font-size: 12px;
  overflow: hidden;
  width: 100vw;
  height: 100vh;
}

#camera-feed {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #000;
  z-index: 1;
}

#cv {
  display: block;
  width: 100%;
  height: 100%;
}

#video {
  position: fixed;
  left: -10000px;
  top: -10000px;
  width: 1px;
  height: 1px;
  opacity: 0;
}

#ui {
  position: fixed;
  top: 10px;
  left: 10px;
  background: rgba(0,0,0,0.95);
  padding: 12px;
  border: 2px solid #0f0;
  color: #0f0;
  max-width: 420px;
  max-height: 85vh;
  overflow-y: auto;
  z-index: 100;
  box-shadow: 0 0 10px rgba(0,255,0,0.3);
}

#ui b {
  font-size: 14px;
}

.status-line {
  margin: 5px 0;
  padding: 3px 0;
  border-bottom: 1px solid #033;
  font-size: 11px;
}

.status-good { color: #0f0; }
.status-warn { color: #ff0; }
.status-bad { color: #f00; }
.status-neutral { color: #aaa; }

.controls {
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid #033;
  font-size: 11px;
}

.robot-sim {
  position: fixed;
  bottom: 10px;
  right: 10px;
  border: 2px solid #0f0;
  background: rgba(0,20,0,0.95);
  z-index: 50;
  box-shadow: 0 0 10px rgba(0,255,0,0.2);
}

#fps-counter {
  position: fixed;
  bottom: 10px;
  left: 10px;
  background: rgba(0,0,0,0.8);
  padding: 5px 10px;
  border: 1px solid #0f0;
  color: #0f0;
  font-size: 11px;
  z-index: 40;
}

::-webkit-scrollbar {
  width: 6px;
}
::-webkit-scrollbar-track {
  background: #111;
}
::-webkit-scrollbar-thumb {
  background: #0f0;
  border-radius: 3px;
}
</style>
</head>
<body>

<div id="camera-feed">
  <canvas id="cv"></canvas>
</div>

<div id="ui">
  <b>‚öôÔ∏è A-1 Robot Vision System</b><br>
  
  <div class="status-line">
    üì∑ Camera: <span id="camera-status" class="status-neutral">ÂàùÊúüÂåñ‰∏≠...</span>
  </div>
  
  <div class="status-line">
    üîç Edge Detection: <span id="edge-status" class="status-neutral">ÂæÖÊ©ü‰∏≠</span>
  </div>
  
  <div class="status-line">
    ü§ñ COCO-SSD: <span id="ml-status" class="status-warn">OFF (M „Åß ON)</span>
  </div>
  
  <div class="status-line">
    üìä Obstacle Score: <span id="obs-score" class="status-warn">0.000</span>
  </div>
  
  <div class="status-line">
    üí≠ Gemma Status: <span id="gemma-status" class="status-neutral">ÂæÖÊ©ü‰∏≠</span>
  </div>
  
  <div class="status-line">
    üöó Robot Mode: <span id="robot-mode" class="status-warn">OFF</span>
  </div>
  
  <div class="status-line">
    üìç Last Decision: <span id="last-decision" class="status-neutral">-</span>
  </div>

  <div class="controls">
    <b>‚å®Ô∏è Êìç‰Ωú„Ç≠„Éº:</b><br>
    <span style="color: #0f0;">M</span> = ML ON/OFF<br>
    <span style="color: #0f0;">R</span> = Robot ON/OFF<br>
    <span style="color: #0f0;">O</span> = Auto/Manual<br>
    <span style="color: #0f0;">X</span> = Emergency Stop<br>
    <span style="color: #0f0;">D</span> = Edge Display<br>
    <span style="color: #0f0;">Space</span> = Freeze<br>
    <span style="color: #0f0;">W/A/S/D</span> = Manual<br>
    <span style="color: #0f0;">G</span> = Ask Gemma<br>
  </div>
</div>

<div id="fps-counter">
  <span id="fps">FPS: 0</span>
</div>

<canvas id="robot-sim" class="robot-sim" width="240" height="240"></canvas>

<video id="video" autoplay playsinline muted></video>

<script src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
/* ==================== „Ç∞„É≠„Éº„Éê„É´Áä∂ÊÖã ==================== */
const state = {
  cvReady: false,
  procW: 320,
  procH: 240,
  videoW: 0,
  videoH: 0,
  frozen: false,
  debugEdges: true,
  
  mlEnabled: false,
  mlReady: false,
  mlLoading: false,
  mlInFlight: false,
  mlNextAtMs: 0,
  mlIntervalMs: 500,
  mlMinScore: 0.5,
  mlLastClass: '',
  mlLastScore: 0,
  mlLastBox: null,
  lastObstacleScore: 0,
  
  robotEnabled: false,
  robotAutoMode: true,
  robotX: 120,
  robotY: 120,
  robotTheta: 0,
  robotVLin: 0,
  robotVAng: 0,
  robotTrail: [],
  
  gemmaLastDecision: '',
  gemmaNextAtMs: 0,
  gemmaIntervalMs: 800,
};

const ML_ALLOWED = new Set([
  'chair', 'couch', 'bed', 'dining table', 'tv', 'laptop', 'keyboard', 'mouse',
  'refrigerator', 'microwave', 'oven', 'sink', 'toilet', 'potted plant',
  'bottle', 'cup', 'backpack', 'suitcase', 'book', 'vase',
  'dog', 'cat', 'bird', 'horse', 'cow', 'elephant', 'bear', 'person'
]);

/* ==================== DOMË¶ÅÁ¥† ==================== */
const video = document.getElementById('video');
const cvCanvas = document.getElementById('cv');

/* ==================== „Ç´„É°„É©ÂàùÊúüÂåñ ==================== */
async function initCamera() {
  try {
    const constraints = {
      audio: false,
      video: {
        facingMode: { ideal: 'environment' },
        width: { ideal: 640 },
        height: { ideal: 480 },
      },
    };

    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    
    return new Promise((resolve) => {
      video.onloadedmetadata = () => {
        video.play().catch(e => console.error('Play error:', e));
        updateStatus('camera-status', `Ready (${video.videoWidth}x${video.videoHeight})`, 'good');
        resolve();
      };
    });
  } catch (err) {
    console.error('Camera error:', err);
    updateStatus('camera-status', `Error: ${err.name}`, 'bad');
    throw err;
  }
}

/* ==================== OpenCVÂàùÊúüÂåñ ==================== */
let cap = null;
let srcRGBA = null;
let procRGBA = null;
let gray = null;
let blur = null;
let edges = null;
let blurKSize = null;
let dilateKernel = null;

function initOpenCV() {
  if (state.cvReady) return;
  if (!cv || !cv.Mat) return;
  if (video.videoWidth === 0) return;

  try {
    cap = new cv.VideoCapture(video);
    state.videoW = video.videoWidth;
    state.videoH = video.videoHeight;

    const aspect = state.videoW / state.videoH;
    state.procW = 320;
    state.procH = Math.floor(320 / aspect);

    cvCanvas.width = state.procW;
    cvCanvas.height = state.procH;

    srcRGBA = new cv.Mat(state.videoH, state.videoW, cv.CV_8UC4);
    procRGBA = new cv.Mat(state.procH, state.procW, cv.CV_8UC4);
    gray = new cv.Mat(state.procH, state.procW, cv.CV_8UC1);
    blur = new cv.Mat(state.procH, state.procW, cv.CV_8UC1);
    edges = new cv.Mat(state.procH, state.procW, cv.CV_8UC1);
    blurKSize = new cv.Size(5, 5);
    dilateKernel = cv.Mat.ones(3, 3, cv.CV_8U);

    state.cvReady = true;
    updateStatus('camera-status', 'OpenCV Ready', 'good');
  } catch (e) {
    console.error('OpenCV init error:', e);
    updateStatus('camera-status', 'OpenCV Error', 'bad');
  }
}

/* ==================== CVÂá¶ÁêÜ ==================== */
function runCvOnce() {
  if (!state.cvReady || state.frozen) return;
  if (video.readyState !== 4) return; // HAVE_ENOUGH_DATA

  try {
    cap.read(srcRGBA);
    cv.resize(srcRGBA, procRGBA, new cv.Size(state.procW, state.procH), 0, 0, cv.INTER_AREA);
    cv.cvtColor(procRGBA, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, blur, blurKSize, 1.1, 1.1, cv.BORDER_DEFAULT);
    cv.equalizeHist(blur, gray);
    cv.Canny(gray, edges, 35, 95);
    cv.dilate(edges, edges, dilateKernel);

    if (state.debugEdges) {
      cv.imshow(cvCanvas, edges);
      drawMlOverlay();
    }

    const nz = cv.countNonZero(edges);
    updateStatus('edge-status', `${nz} pixels`, nz > 0 ? 'good' : 'warn');
  } catch (e) {
    console.error('CV error:', e);
  }
}

function drawMlOverlay() {
  if (!state.mlLastBox || state.mlLastScore < state.mlMinScore) return;

  const ctx = cvCanvas.getContext('2d');
  const b = state.mlLastBox;
  const x = Math.max(0, Math.min(state.procW - 1, b.x));
  const y = Math.max(0, Math.min(state.procH - 1, b.y));
  const w = Math.max(1, Math.min(state.procW - x, b.w));
  const h = Math.max(1, Math.min(state.procH - y, b.h));

  ctx.strokeStyle = 'rgba(0,255,0,0.9)';
  ctx.lineWidth = 2;
  ctx.strokeRect(x, y, w, h);

  const label = `${state.mlLastClass} ${(state.mlLastScore * 100).toFixed(0)}%`;
  ctx.fillStyle = 'rgba(0,255,0,0.8)';
  ctx.fillRect(x, y - 16, 140, 16);
  ctx.fillStyle = '#000';
  ctx.font = '12px monospace';
  ctx.fillText(label, x + 4, y - 4);
}

/* ==================== COCO-SSD ==================== */
let tfRef = null;
let cocoRef = null;

async function ensureCocoSsdLoaded() {
  if (state.mlReady || state.mlLoading) return;
  state.mlLoading = true;
  updateStatus('ml-status', 'Loading...', 'warn');

  try {
    // TensorFlow.js
    if (!window.tf) {
      const tfScript = document.createElement('script');
      tfScript.src = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js';
      await new Promise((resolve, reject) => {
        tfScript.onload = resolve;
        tfScript.onerror = reject;
        document.head.appendChild(tfScript);
      });
    }

    // COCO-SSD
    if (!window.cocoSsd) {
      const cocoScript = document.createElement('script');
      cocoScript.src = 'https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js';
      await new Promise((resolve, reject) => {
        cocoScript.onload = resolve;
        cocoScript.onerror = reject;
        document.head.appendChild(cocoScript);
      });
    }

    tfRef = window.tf;
    cocoRef = window.cocoSsd;

    if (!tfRef || !cocoRef) throw new Error('Libraries not loaded');

    try { await tfRef.setBackend('webgl'); } catch (_) {}
    try { await tfRef.ready(); } catch (_) {}

    state.mlModel = await cocoRef.load({ base: 'lite_mobilenet_v2' });
    state.mlReady = true;
    state.mlLoading = false;
    updateStatus('ml-status', 'Ready', 'good');
  } catch (e) {
    console.error('ML load error:', e);
    state.mlLoading = false;
    updateStatus('ml-status', `Error: ${e.message}`, 'bad');
  }
}

const grabCanvas = document.createElement('canvas');

async function runCocoOnce(nowMs) {
  if (!state.mlEnabled || !state.mlReady) return;
  if (nowMs < state.mlNextAtMs) return;
  state.mlNextAtMs = nowMs + state.mlIntervalMs;
  if (state.mlInFlight || state.frozen) return;

  state.mlInFlight = true;
  try {
    grabCanvas.width = state.procW;
    grabCanvas.height = state.procH;
    const gctx = grabCanvas.getContext('2d');
    gctx.drawImage(video, 0, 0, state.procW, state.procH);

    const preds = await state.mlModel.detect(grabCanvas, 6);
    let best = null;

    for (const p of preds) {
      if (!p || !p.bbox || p.score < state.mlMinScore) continue;
      if (!ML_ALLOWED.has(p.class)) continue;

      const [x, y, w, h] = p.bbox;
      const cy = y + h * 0.5;
      const area = w * h;
      const bottomW = Math.max(0, Math.min(1, (cy - 0.55 * state.procH) / (0.45 * state.procH)));
      const score = p.score * (0.25 + 0.75 * bottomW) * (1 + area / (state.procW * state.procH) * 2.0);

      if (!best || score > best._score) {
        best = { ...p, _score: score };
      }
    }

    if (best) {
      state.mlLastClass = best.class;
      state.mlLastScore = best.score;
      const [x, y, w, h] = best.bbox;
      state.mlLastBox = { x, y, w, h };
      state.lastObstacleScore = Math.round((best._score || 0) * 1000);
      updateStatus('obs-score', (state.lastObstacleScore / 1000).toFixed(3), 'warn');
    } else {
      state.mlLastClass = '';
      state.mlLastScore = 0;
      state.mlLastBox = null;
      state.lastObstacleScore = 0;
    }
  } catch (e) {
    console.error('COCO error:', e);
  }
  state.mlInFlight = false;
}

/* ==================== GemmaÁµ±Âêà ==================== */
async function askGemmaDecision(nowMs) {
  if (!state.mlEnabled || !state.mlReady) return;
  if (nowMs < state.gemmaNextAtMs) return;
  state.gemmaNextAtMs = nowMs + state.gemmaIntervalMs;

  const obs = {
    obstacle_score: state.lastObstacleScore / 1000.0,
    detected_class: state.mlLastClass,
    confidence: state.mlLastScore,
    has_obstacle: state.lastObstacleScore > 500,
  };

  updateStatus('gemma-status', 'Asking...', 'warn');

  try {
    const res = await fetch('https://KGNINJA-FunctionGemmabotdemo-docker.hf.space/decide', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(obs)
    });

    const decision = await res.json();
    applyGemmaDecision(decision);
    state.gemmaLastDecision = decision.action || 'unknown';
    updateStatus('gemma-status', decision.action || 'ready', 'good');
  } catch (e) {
    console.error('Gemma error:', e);
    updateStatus('gemma-status', 'Error', 'bad');
  }
}

function applyGemmaDecision(d) {
  if (!d || !d.action || !state.robotEnabled) return;

  switch (d.action) {
    case 'move_forward':
      sendRobotCommand(0.3, 0);
      break;
    case 'turn_left':
      sendRobotCommand(0.15, 0.5);
      break;
    case 'turn_right':
      sendRobotCommand(0.15, -0.5);
      break;
    default:
      emergencyStop();
  }
}

/* ==================== „É≠„Éú„ÉÉ„ÉàÂà∂Âæ° ==================== */
function sendRobotCommand(lin, ang) {
  state.robotVLin = Math.max(-0.5, Math.min(0.5, lin));
  state.robotVAng = Math.max(-1.0, Math.min(1.0, ang));
}

function emergencyStop() {
  state.robotVLin = 0;
  state.robotVAng = 0;
}

function updateRobotSim(dt) {
  if (!state.robotEnabled) return;

  state.robotTheta += state.robotVAng * dt;
  state.robotX += Math.cos(state.robotTheta) * state.robotVLin * dt * 80;
  state.robotY += Math.sin(state.robotTheta) * state.robotVLin * dt * 80;

  const SIM = 240;
  state.robotX = Math.max(10, Math.min(SIM - 10, state.robotX));
  state.robotY = Math.max(10, Math.min(SIM - 10, state.robotY));

  state.robotTrail.push({ x: state.robotX, y: state.robotY });
  if (state.robotTrail.length > 200) state.robotTrail.shift();
}

function drawRobotSim() {
  const canvas = document.getElementById('robot-sim');
  const ctx = canvas.getContext('2d');
  const SIM = 240;

  ctx.fillStyle = '#001';
  ctx.fillRect(0, 0, SIM, SIM);

  // Grid
  ctx.strokeStyle = 'rgba(0,100,0,0.2)';
  for (let i = 0; i <= SIM; i += 40) {
    ctx.beginPath();
    ctx.moveTo(i, 0);
    ctx.lineTo(i, SIM);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, i);
    ctx.lineTo(SIM, i);
    ctx.stroke();
  }

  // Trail
  if (state.robotTrail.length > 1) {
    ctx.strokeStyle = 'rgba(0,255,0,0.4)';
    ctx.beginPath();
    state.robotTrail.forEach((p, i) => {
      if (i === 0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    });
    ctx.stroke();
  }

  // Robot
  ctx.save();
  ctx.translate(state.robotX, state.robotY);
  ctx.rotate(state.robotTheta);
  ctx.fillStyle = state.robotEnabled ? '#0f0' : '#555';
  ctx.beginPath();
  ctx.moveTo(10, 0);
  ctx.lineTo(-10, -6);
  ctx.lineTo(-10, 6);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // Info
  ctx.fillStyle = '#0f0';
  ctx.font = '10px monospace';
  ctx.fillText(`v:${state.robotVLin.toFixed(2)}`, 5, 14);
  ctx.fillText(`w:${state.robotVAng.toFixed(2)}`, 5, 24);
}

/* ==================== UIÊõ¥Êñ∞ ==================== */
function updateStatus(id, text, className) {
  const el = document.getElementById(id);
  if (el) {
    el.textContent = text;
    el.className = `status-${className}`;
  }
}

/* ==================== „Ç≠„ÉºÂÖ•Âäõ ==================== */
const keys = {};

window.addEventListener('keydown', (ev) => {
  keys[ev.code] = true;

  if (ev.code === 'Space') {
    ev.preventDefault();
    state.frozen = !state.frozen;
    updateStatus('edge-status', state.frozen ? 'FROZEN' : 'Running', state.frozen ? 'warn' : 'good');
  } else if (ev.code === 'KeyM') {
    state.mlEnabled = !state.mlEnabled;
    if (state.mlEnabled) ensureCocoSsdLoaded();
    updateStatus('ml-status', state.mlEnabled ? 'Loading...' : 'OFF', state.mlEnabled ? 'warn' : 'warn');
  } else if (ev.code === 'KeyR') {
    state.robotEnabled = !state.robotEnabled;
    updateStatus('robot-mode', state.robotEnabled ? 'ON' : 'OFF', state.robotEnabled ? 'good' : 'warn');
  } else if (ev.code === 'KeyX') {
    emergencyStop();
  } else if (ev.code === 'KeyD') {
    state.debugEdges = !state.debugEdges;
  }
});

window.addEventListener('keyup', (ev) => {
  keys[ev.code] = false;
});

/* ==================== „É°„Ç§„É≥„É´„Éº„Éó ==================== */
let lastCvAt = 0;
let fpsFrames = 0;
let fpsAccMs = 0;

function animate() {
  requestAnimationFrame(animate);

  const nowMs = performance.now();

  if (!state.cvReady) {
    initOpenCV();
  }

  if (nowMs - lastCvAt > 90) {
    runCvOnce();
    lastCvAt = nowMs;
  }

  runCocoOnce(nowMs);
  askGemmaDecision(nowMs);

  if (state.robotEnabled) {
    updateRobotSim(0.1);
    drawRobotSim();
  }

  fpsFrames++;
  fpsAccMs += 16;
  if (fpsAccMs >= 500) {
    const fps = Math.round((fpsFrames * 1000) / fpsAccMs);
    document.getElementById('fps').textContent = `FPS: ${fps}`;
    fpsFrames = 0;
    fpsAccMs = 0;
  }
}

// OpenCVÂàùÊúüÂåñÂÆå‰∫ÜÂæå„Å´„Çπ„Çø„Éº„Éà
cv['onRuntimeInitialized'] = async () => {
  try {
    await initCamera();
    animate();
  } catch (e) {
    console.error('Startup error:', e);
    updateStatus('camera-status', 'Camera unavailable', 'bad');
  }
};
</script>

</body>
</html>
