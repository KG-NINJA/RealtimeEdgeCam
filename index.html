<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>A-1 Robot Vision - Smooth Control</title>
<style>
* { box-sizing: border-box; }
body { 
  margin: 0; padding: 0; 
  background: #000; color: #0f0; 
  font-family: 'Courier New', monospace; 
  font-size: 14px; 
  overflow: hidden; 
  width: 100vw; height: 100vh; 
}
#camera-feed { 
  position: absolute; top: 0; left: 0; 
  width: 100%; height: 100%; 
  z-index: 1; 
}
#cv { display: block; width: 100%; height: 100%; }
#ui { 
  position: fixed; top: 15px; left: 15px; 
  background: rgba(0, 0, 0, 0.95); 
  padding: 15px; 
  border: 2px solid #0f0; 
  z-index: 100;
  min-width: 280px;
  box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
}
.status-line { 
  margin: 8px 0; 
  padding: 5px 0;
  border-bottom: 1px solid #033; 
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.label { flex: 1; }
.value { 
  font-weight: bold; 
  padding: 0 8px;
  min-width: 80px;
  text-align: right;
}
.robot-sim { 
  position: fixed; 
  bottom: 15px; right: 15px; 
  border: 3px solid #0f0; 
  background: rgba(0, 15, 0, 0.95); 
  z-index: 50;
  box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
}
#video { position: fixed; left: -10000px; opacity: 0; }
#keys-info {
  position: fixed;
  bottom: 15px;
  left: 15px;
  background: rgba(0, 0, 0, 0.95);
  border: 2px solid #0f0;
  padding: 10px;
  font-size: 12px;
  z-index: 50;
  box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
}
</style>
</head>
<body>

<div id="camera-feed"><canvas id="cv"></canvas></div>

<div id="ui">
  <div style="margin-bottom: 10px; font-weight: bold; font-size: 16px; text-shadow: 0 0 10px #0f0;">
    âš™ï¸ A-1 ROBOT VISION
  </div>
  <div class="status-line">
    <span class="label">ğŸ¯ éšœå®³ç‰©è·é›¢</span>
    <span class="value" id="obs-score">100</span>
  </div>
  <div class="status-line">
    <span class="label">ğŸ§  Gemmaæ€è€ƒ</span>
    <span class="value" id="gemma-status">å¾…æ©Ÿä¸­</span>
  </div>
  <div class="status-line">
    <span class="label">ğŸ¤– ãƒ­ãƒœãƒƒãƒˆçŠ¶æ…‹</span>
    <span class="value" id="robot-mode" style="color:#f00">åœæ­¢ä¸­</span>
  </div>
  <div class="status-line">
    <span class="label">ğŸ“ ç¾åœ¨ã®æŒ‡ç¤º</span>
    <span class="value" id="last-decision">-</span>
  </div>
  <div class="status-line">
    <span class="label">âš¡ é€Ÿåº¦</span>
    <span class="value" id="speed-display">0.0</span>
  </div>
</div>

<div id="keys-info">
  <div style="font-weight: bold; margin-bottom: 5px;">æ“ä½œã‚­ãƒ¼</div>
  <div>M ã‚­ãƒ¼: AIèªè­˜ ON/OFF</div>
  <div>R ã‚­ãƒ¼: ãƒ­ãƒœãƒƒãƒˆå‹•ä½œ ON/OFF</div>
</div>

<canvas id="robot-sim" class="robot-sim" width="280" height="280"></canvas>
<video id="video" autoplay playsinline muted></video>

<script src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
const state = {
  cvReady: false,
  mlReady: false,
  mlEnabled: false,
  mlInFlight: false,
  lastObstacleScore: 100,
  robotEnabled: false,
  
  robotX: 140,
  robotY: 140,
  robotTheta: 0,
  robotVLin: 0,
  robotVAng: 0,
  targetVLin: 0,
  targetVAng: 0,
  
  gemmaLastAction: 'WAITING',
  gemmaNextAt: 0,
  gemmaThinking: false
};

const video = document.getElementById('video');
const cvCanvas = document.getElementById('cv');

async function loadML() {
  if (window.tf && window.cocoSsd) return;
  
  console.log("Loading TensorFlow.js...");
  
  try {
    if (!window.tf) {
      await loadScript("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0");
    }
    if (!window.cocoSsd) {
      await loadScript("https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3");
    }
    state.model = await cocoSsd.load();
    state.mlReady = true;
    document.getElementById('gemma-status').textContent = 'æº–å‚™å®Œäº†';
    console.log("ML Model Ready");
  } catch (e) {
    console.error("ML Load Error:", e);
    document.getElementById('gemma-status').textContent = 'ã‚¨ãƒ©ãƒ¼';
  }
}

function loadScript(src) {
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = src;
    s.onload = resolve;
    s.onerror = reject;
    document.head.appendChild(s);
  });
}

const capCanvas = document.createElement('canvas');
const capCtx = capCanvas.getContext('2d', { willReadFrequently: true });

function runCV() {
  if (!state.cvReady || !video.videoWidth) return;
  
  capCanvas.width = video.videoWidth;
  capCanvas.height = video.videoHeight;
  capCtx.drawImage(video, 0, 0);
  
  let src = cv.matFromImageData(capCtx.getImageData(0, 0, video.videoWidth, video.videoHeight));
  let gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.Canny(gray, gray, 50, 100);
  cv.imshow(cvCanvas, gray);
  
  src.delete();
  gray.delete();
}

async function runML() {
  if (!state.mlEnabled || !state.mlReady || state.mlInFlight) return;
  
  state.mlInFlight = true;
  
  try {
    const preds = await state.model.detect(capCanvas);
    
    if (preds.length > 0) {
      let obj = preds.sort((a, b) => b.score - a.score)[0];
      state.lastObstacleScore = Math.max(5, Math.min(100, Math.round(obj.score * 100)));
    } else {
      state.lastObstacleScore = 100;
    }
    
    document.getElementById('obs-score').textContent = state.lastObstacleScore;
    
  } catch (e) {
    console.error("ML Error:", e);
  } finally {
    state.mlInFlight = false;
  }
}

async function askGemma(now) {
  if (!state.robotEnabled || now < state.gemmaNextAt || state.gemmaThinking) return;
  
  state.gemmaThinking = true;
  state.gemmaNextAt = now + 2500;
  document.getElementById('gemma-status').textContent = 'æ€è€ƒä¸­...';
  
  const distance = state.lastObstacleScore;
  console.log("Distance:", distance);
  
  try {
    const res = await fetch('https://kgninja-functiongemmabotdemo-docker.hf.space/decide', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        front_distance: distance,
        speed: state.robotVLin
      })
    });
    
    const json = await res.json();
    console.log("API Response:", json);
    
    let action = null;
    
    if (json.data && json.data[0]) {
      const match = json.data[0].match(/\{.*\}/s);
      if (match) {
        const d = JSON.parse(match[0]);
        action = (d.action || '').toLowerCase();
        console.log("Parsed action:", action);
      }
    }
    
    // APIãŒç„¡åŠ¹ãªå¿œç­”ã®å ´åˆã€è·é›¢ãƒ™ãƒ¼ã‚¹ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    if (!action) {
      console.warn("âš ï¸ API invalid, using fallback logic");
      if (distance < 30) {
        action = Math.random() > 0.5 ? 'turn_left' : 'turn_right';
      } else if (distance < 60) {
        const actions = ['move_forward', 'turn_left', 'turn_right'];
        action = actions[Math.floor(Math.random() * 3)];
      } else {
        action = 'move_forward';
      }
      console.log("Fallback action:", action);
    }
    
    state.gemmaLastAction = action.toUpperCase().replace('_', ' ');
    document.getElementById('last-decision').textContent = state.gemmaLastAction;
    document.getElementById('gemma-status').textContent = 'å®Œäº† âœ“';
    
    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«åŸºã¥ã„ã¦ç›®æ¨™é€Ÿåº¦ã‚’è¨­å®š
    if (action === 'move_forward') {
      state.targetVLin = 0.8;
      state.targetVAng = 0;
      console.log("â†’ FORWARD");
    } else if (action === 'turn_left') {
      state.targetVLin = 0.3;
      state.targetVAng = -2.0;  // å·¦å›è»¢
      console.log("â†’ LEFT");
    } else if (action === 'turn_right') {
      state.targetVLin = 0.3;
      state.targetVAng = 2.0;   // å³å›è»¢
      console.log("â†’ RIGHT");
    } else {
      state.targetVLin = 0;
      state.targetVAng = 0;
      console.log("â†’ STOP");
    }
    
  } catch (e) {
    console.error("Gemma API Error:", e);
    document.getElementById('gemma-status').textContent = 'APIå¤±æ•—';
    state.targetVLin = 0;
    state.targetVAng = 0;
  } finally {
    state.gemmaThinking = false;
  }
}

function animate(now) {
  if (!state.cvReady && video.videoWidth > 0) {
    cvCanvas.width = 320;
    cvCanvas.height = 240;
    state.cvReady = true;
  }
  
  runCV();
  runML();
  
  if (state.mlEnabled) {
    askGemma(now);
  }
  
  if (state.robotEnabled) {
    state.robotVLin += (state.targetVLin - state.robotVLin) * 0.15;
    state.robotVAng += (state.targetVAng - state.robotVAng) * 0.15;
    
    state.robotTheta += state.robotVAng * 0.016;
    state.robotX += Math.cos(state.robotTheta) * state.robotVLin * 3;
    state.robotY += Math.sin(state.robotTheta) * state.robotVLin * 3;
    
    state.robotX = Math.max(15, Math.min(265, state.robotX));
    state.robotY = Math.max(15, Math.min(265, state.robotY));
  }
  
  document.getElementById('speed-display').textContent = state.robotVLin.toFixed(2);
  
  drawSimulator();
  
  requestAnimationFrame(animate);
}

function drawSimulator() {
  const canvas = document.getElementById('robot-sim');
  const ctx = canvas.getContext('2d');
  
  ctx.fillStyle = 'rgba(0, 15, 0, 0.95)';
  ctx.fillRect(0, 0, 280, 280);
  
  ctx.strokeStyle = 'rgba(0, 255, 0, 0.1)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 280; i += 28) {
    ctx.beginPath();
    ctx.moveTo(i, 0);
    ctx.lineTo(i, 280);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, i);
    ctx.lineTo(280, i);
    ctx.stroke();
  }
  
  ctx.font = 'bold 16px monospace';
  ctx.fillStyle = '#0f0';
  ctx.fillText('AI: ' + state.gemmaLastAction, 15, 30);
  
  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fillRect(15, 45, 100, 20);
  ctx.strokeStyle = '#0f0';
  ctx.strokeRect(15, 45, 100, 20);
  
  const fillWidth = (state.lastObstacleScore / 100) * 100;
  ctx.fillStyle = state.lastObstacleScore > 50 ? '#0f0' : state.lastObstacleScore > 20 ? '#ff0' : '#f00';
  ctx.fillRect(15, 45, fillWidth, 20);
  
  ctx.font = '11px monospace';
  ctx.fillStyle = '#0f0';
  ctx.fillText('è·é›¢: ' + state.lastObstacleScore, 20, 58);
  
  ctx.save();
  ctx.translate(state.robotX, state.robotY);
  ctx.rotate(state.robotTheta);
  
  ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
  ctx.beginPath();
  ctx.arc(0, 0, 12, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  ctx.fillStyle = '#0f0';
  ctx.beginPath();
  ctx.moveTo(0, -12);
  ctx.lineTo(-6, 6);
  ctx.lineTo(6, 6);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
  
  ctx.font = '10px monospace';
  ctx.fillStyle = 'rgba(0, 255, 0, 0.6)';
  ctx.fillText('é€Ÿåº¦: ' + state.robotVLin.toFixed(2), 15, 270);
  ctx.fillText('è§’é€Ÿåº¦: ' + state.robotVAng.toFixed(1), 120, 270);
  
  if (!state.robotEnabled) {
    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
    ctx.font = 'bold 20px monospace';
    ctx.fillText('STOPPED', 70, 140);
  }
}

window.addEventListener('keydown', e => {
  if (e.code === 'KeyM') {
    state.mlEnabled = !state.mlEnabled;
    if (state.mlEnabled) {
      loadML();
      document.getElementById('gemma-status').textContent = 'èª­ã¿è¾¼ã¿ä¸­...';
    } else {
      document.getElementById('gemma-status').textContent = 'ç„¡åŠ¹';
      document.getElementById('last-decision').textContent = '-';
    }
  }
  
  if (e.code === 'KeyR') {
    state.robotEnabled = !state.robotEnabled;
    const modeEl = document.getElementById('robot-mode');
    modeEl.textContent = state.robotEnabled ? 'ç¨¼åƒä¸­' : 'åœæ­¢ä¸­';
    modeEl.style.color = state.robotEnabled ? '#0f0' : '#f00';
    
    if (!state.robotEnabled) {
      state.targetVLin = 0;
      state.targetVAng = 0;
      state.robotVLin = 0;
      state.robotVAng = 0;
    }
  }
});

cv['onRuntimeInitialized'] = () => {
  navigator.mediaDevices.getUserMedia({ video: true }).then(s => {
    video.srcObject = s;
    video.play();
    requestAnimationFrame(animate);
    console.log("System Ready - Press M to enable AI, R to enable Robot");
  });
};
</script>

</body>
</html>
