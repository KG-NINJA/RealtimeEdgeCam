<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>A-1 Robot Vision - Smooth Control</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<style>
* { box-sizing: border-box; }
body { 
  margin: 0; padding: 0; 
  background: #000; color: #0f0; 
  font-family: 'Courier New', monospace; 
  font-size: 14px; 
  overflow: hidden; 
  width: 100vw; height: 100vh;
  touch-action: manipulation;
}

/* PC / „Çø„Éñ„É¨„ÉÉ„Éà */
@media (min-width: 768px) {
  #camera-feed { 
    position: absolute; top: 0; left: 0; 
    width: 100%; height: 100%; 
    z-index: 1; 
  }
  #cv { display: block; width: 100%; height: 100%; }
  
  #ui { 
    position: fixed; top: 15px; left: 15px; 
    background: rgba(0, 0, 0, 0.95); 
    padding: 15px; 
    border: 2px solid #0f0; 
    z-index: 100;
    min-width: 280px;
    max-height: 300px;
    overflow-y: auto;
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
  }
  
  .robot-sim { 
    position: fixed; 
    bottom: 15px; right: 15px; 
    border: 3px solid #0f0; 
    background: rgba(0, 15, 0, 0.95); 
    z-index: 50;
    width: 280px;
    height: 280px;
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
  }
  
  #steer-gauge {
    position: fixed;
    top: 340px;
    left: 15px;
    width: 280px;
    height: 30px;
    z-index: 50;
    border: 2px solid #0f0;
    background: rgba(0, 0, 0, 0.95);
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
  }
  
  #keys-info {
    position: fixed;
    bottom: 15px;
    left: 15px;
    background: rgba(0, 0, 0, 0.95);
    border: 2px solid #0f0;
    padding: 10px;
    font-size: 11px;
    z-index: 49;
    max-width: 280px;
    display: block;
  }
}

/* „Çπ„Éû„Éº„Éà„Éï„Ç©„É≥ */
@media (max-width: 767px) {
  body { font-size: 12px; }
  
  #camera-feed { 
    position: absolute; top: 0; left: 0; 
    width: 100%; height: 60%; 
    z-index: 1; 
  }
  #cv { display: block; width: 100%; height: 100%; }
  
  #ui { 
    position: fixed; 
    top: 60%; left: 0; right: 0;
    bottom: 60px;
    background: rgba(0, 0, 0, 0.98); 
    padding: 10px; 
    border-top: 2px solid #0f0;
    z-index: 100;
    overflow-y: auto;
    max-height: calc(40vh - 60px);
  }
  
  .status-line { 
    margin: 4px 0; 
    padding: 3px 0;
    font-size: 12px;
  }
  
  .value { 
    min-width: 60px;
    font-size: 12px;
  }
  
  .robot-sim { 
    position: fixed; 
    top: 60%; right: 0;
    width: 160px;
    height: 160px;
    border: 2px solid #0f0; 
    background: rgba(0, 15, 0, 0.95); 
    z-index: 50;
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
  }
  
  #steer-gauge {
    position: fixed;
    top: 60%;
    left: 0;
    right: 160px;
    height: 30px;
    z-index: 50;
    border: 2px solid #0f0;
    background: rgba(0, 0, 0, 0.95);
  }
  
  #keys-info {
    display: none;
  }
  
  /* „Çø„ÉÉ„ÉÅ„Éú„Çø„É≥ */
  #touch-controls {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 60px;
    background: rgba(0, 0, 0, 0.95);
    border-top: 1px solid #0f0;
    display: flex;
    z-index: 101;
  }
  
  .touch-btn {
    flex: 1;
    border: 1px solid #0f0;
    background: rgba(0, 30, 0, 0.8);
    color: #0f0;
    font-weight: bold;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    transition: all 0.1s;
  }
  
  .touch-btn:active {
    background: rgba(0, 255, 0, 0.3);
    box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.5);
  }
  
  .touch-btn:hover {
    background: rgba(0, 50, 0, 0.9);
  }
}

.status-line { 
  margin: 8px 0; 
  padding: 5px 0;
  border-bottom: 1px solid #033; 
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.label { flex: 1; }
.value { 
  font-weight: bold; 
  padding: 0 8px;
  text-align: right;
}
#video { position: fixed; left: -10000px; opacity: 0; }
</style>
</head>
<body>

<div id="camera-feed"><canvas id="cv"></canvas></div>

<div id="ui">
  <div style="margin-bottom: 10px; font-weight: bold; font-size: 16px; text-shadow: 0 0 10px #0f0;">
    ‚öôÔ∏è A-1 ROBOT VISION
  </div>
  <div class="status-line">
    <span class="label">üéØ ÈöúÂÆ≥Áâ©Ë∑ùÈõ¢</span>
    <span class="value" id="obs-score">100</span>
  </div>
  <div class="status-line">
    <span class="label">üß† GemmaÊÄùËÄÉ</span>
    <span class="value" id="gemma-status">ÂæÖÊ©ü‰∏≠</span>
  </div>
  <div class="status-line">
    <span class="label">ü§ñ „É≠„Éú„ÉÉ„ÉàÁä∂ÊÖã</span>
    <span class="value" id="robot-mode" style="color:#f00">ÂÅúÊ≠¢‰∏≠</span>
  </div>
  <div class="status-line">
    <span class="label">üìç ÁèæÂú®„ÅÆÊåáÁ§∫</span>
    <span class="value" id="last-decision">-</span>
  </div>
  <div class="status-line">
    <span class="label">‚ö° ÈÄüÂ∫¶</span>
    <span class="value" id="speed-display">0.0</span>
  </div>
  <div class="status-line">
    <span class="label">üéØ „Çπ„ÉÜ„Ç¢„É™„É≥„Ç∞</span>
    <span class="value" id="steer-display">‚Üí ‰∏≠Á´ã</span>
  </div>
</div>

<canvas id="steer-gauge" width="280" height="30"></canvas>

<div id="keys-info">
  <div style="font-weight: bold; margin-bottom: 5px;">Êìç‰Ωú„Ç≠„Éº</div>
  <div>M „Ç≠„Éº: AIË™çË≠ò ON/OFF</div>
  <div>R „Ç≠„Éº: „É≠„Éú„ÉÉ„ÉàÂãï‰Ωú ON/OFF</div>
</div>

<canvas id="robot-sim" class="robot-sim" width="280" height="280"></canvas>
<video id="video" autoplay playsinline muted></video>

<!-- „Çπ„Éû„Éº„Éà„Éï„Ç©„É≥Áî®„Çø„ÉÉ„ÉÅ„Ç≥„É≥„Éà„É≠„Éº„É´ -->
<div id="touch-controls">
  <button class="touch-btn" id="btn-ai">üß† AI</button>
  <button class="touch-btn" id="btn-robot">ü§ñ Âãï‰Ωú</button>
  <button class="touch-btn" id="btn-camera">üìπ</button>
  <button class="touch-btn" id="btn-info">‚ÑπÔ∏è</button>
</div>

<script src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
const state = {
  cvReady: false,
  mlReady: false,
  mlEnabled: false,
  mlInFlight: false,
  lastObstacleScore: 100,
  robotEnabled: false,
  
  robotX: 140,
  robotY: 140,
  robotTheta: 0,
  robotVLin: 0,
  robotVAng: 0,
  targetVLin: 0,
  targetVAng: 0,
  
  gemmaLastAction: 'WAITING',
  gemmaNextAt: 0,
  gemmaThinking: false,
  
  steerValue: 0,
  steerNextAt: 0
};

const video = document.getElementById('video');
const cvCanvas = document.getElementById('cv');

async function loadML() {
  if (window.tf && window.cocoSsd) return;
  
  console.log("Loading TensorFlow.js...");
  
  try {
    if (!window.tf) {
      await loadScript("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0");
    }
    if (!window.cocoSsd) {
      await loadScript("https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3");
    }
    state.model = await cocoSsd.load();
    state.mlReady = true;
    document.getElementById('gemma-status').textContent = 'Ê∫ñÂÇôÂÆå‰∫Ü';
    console.log("ML Model Ready");
  } catch (e) {
    console.error("ML Load Error:", e);
    document.getElementById('gemma-status').textContent = '„Ç®„É©„Éº';
  }
}

function loadScript(src) {
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = src;
    s.onload = resolve;
    s.onerror = reject;
    document.head.appendChild(s);
  });
}

const capCanvas = document.createElement('canvas');
const capCtx = capCanvas.getContext('2d', { willReadFrequently: true });

function runCV() {
  if (!state.cvReady || !video.videoWidth) return;
  
  capCanvas.width = video.videoWidth;
  capCanvas.height = video.videoHeight;
  capCtx.drawImage(video, 0, 0);
  
  let src = cv.matFromImageData(capCtx.getImageData(0, 0, video.videoWidth, video.videoHeight));
  let gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.Canny(gray, gray, 50, 100);
  cv.imshow(cvCanvas, gray);
  
  src.delete();
  gray.delete();
}

async function runML() {
  if (!state.mlEnabled || !state.mlReady || state.mlInFlight) return;
  
  state.mlInFlight = true;
  
  try {
    const preds = await state.model.detect(capCanvas);
    
    if (preds.length > 0) {
      let obj = preds.sort((a, b) => b.score - a.score)[0];
      state.lastObstacleScore = Math.max(5, Math.min(100, Math.round(obj.score * 100)));
    } else {
      state.lastObstacleScore = 100;
    }
    
    document.getElementById('obs-score').textContent = state.lastObstacleScore;
    
  } catch (e) {
    console.error("ML Error:", e);
  } finally {
    state.mlInFlight = false;
  }
}

const steeringGradient = {
  columns: new Float32Array(9),
  bestSteer: 0
};

function calculateSteering() {
  const now = performance.now();
  
  if (now < state.steerNextAt) return;
  state.steerNextAt = now + 200;
  
  let sum = 0;
  for (let i = 0; i < steeringGradient.columns.length; i++) {
    steeringGradient.columns[i] += (Math.random() - 0.5) * 0.3;
    steeringGradient.columns[i] = Math.max(0, Math.min(1, steeringGradient.columns[i]));
    sum += steeringGradient.columns[i];
  }
  
  let minIdx = 0;
  let minVal = Infinity;
  for (let i = 0; i < steeringGradient.columns.length; i++) {
    if (steeringGradient.columns[i] < minVal) {
      minVal = steeringGradient.columns[i];
      minIdx = i;
    }
  }
  
  const mid = (steeringGradient.columns.length - 1) / 2;
  state.steerValue = (minIdx - mid) / mid;
  
  let steerLabel = '‚Üí ‰∏≠Á´ã';
  if (state.steerValue < -0.3) {
    steerLabel = '‚Üê Â∑¶Âç±Èô∫';
  } else if (state.steerValue > 0.3) {
    steerLabel = 'Âè≥Âç±Èô∫ ‚Üí';
  }
  document.getElementById('steer-display').textContent = steerLabel;
}

async function askGemma(now) {
  if (!state.robotEnabled || now < state.gemmaNextAt || state.gemmaThinking) return;
  
  state.gemmaThinking = true;
  state.gemmaNextAt = now + 2500;
  document.getElementById('gemma-status').textContent = 'ÊÄùËÄÉ‰∏≠...';
  
  const distance = state.lastObstacleScore;
  console.log("Distance:", distance);
  
  try {
    const res = await fetch('https://kgninja-functiongemmabotdemo-docker.hf.space/decide', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        front_distance: distance,
        speed: state.robotVLin,
        steer: state.steerValue
      })
    });
    
    const json = await res.json();
    console.log("API Response:", json);
    
    let action = null;
    
    if (json.data && json.data[0]) {
      const match = json.data[0].match(/\{.*\}/s);
      if (match) {
        const d = JSON.parse(match[0]);
        action = (d.action || '').toLowerCase();
        console.log("Parsed action:", action);
      }
    }
    
    if (!action) {
      console.warn("‚ö†Ô∏è API invalid, using fallback logic");
      if (distance < 30) {
        action = Math.random() > 0.5 ? 'turn_left' : 'turn_right';
      } else if (distance < 60) {
        const actions = ['move_forward', 'turn_left', 'turn_right'];
        action = actions[Math.floor(Math.random() * 3)];
      } else {
        action = 'move_forward';
      }
      console.log("Fallback action:", action);
    }
    
    state.gemmaLastAction = action.toUpperCase().replace('_', ' ');
    document.getElementById('last-decision').textContent = state.gemmaLastAction;
    document.getElementById('gemma-status').textContent = 'ÂÆå‰∫Ü ‚úì';
    
    if (action === 'move_forward') {
      state.targetVLin = 0.8;
      state.targetVAng = 0;
      console.log("‚Üí FORWARD");
    } else if (action === 'turn_left') {
      state.targetVLin = 0.3;
      state.targetVAng = -2.0;
      console.log("‚Üí LEFT");
    } else if (action === 'turn_right') {
      state.targetVLin = 0.3;
      state.targetVAng = 2.0;
      console.log("‚Üí RIGHT");
    } else {
      state.targetVLin = 0;
      state.targetVAng = 0;
      console.log("‚Üí STOP");
    }
    
  } catch (e) {
    console.error("Gemma API Error:", e);
    document.getElementById('gemma-status').textContent = 'APIÂ§±Êïó';
    state.targetVLin = 0;
    state.targetVAng = 0;
  } finally {
    state.gemmaThinking = false;
  }
}

function animate(now) {
  if (!state.cvReady && video.videoWidth > 0) {
    cvCanvas.width = 320;
    cvCanvas.height = 240;
    state.cvReady = true;
  }
  
  runCV();
  runML();
  calculateSteering();
  
  if (state.mlEnabled) {
    askGemma(now);
  }
  
  if (state.robotEnabled) {
    state.robotVLin += (state.targetVLin - state.robotVLin) * 0.15;
    state.robotVAng += (state.targetVAng - state.robotVAng) * 0.15;
    
    state.robotTheta += state.robotVAng * 0.016;
    state.robotX += Math.cos(state.robotTheta) * state.robotVLin * 3;
    state.robotY += Math.sin(state.robotTheta) * state.robotVLin * 3;
    
    state.robotX = Math.max(15, Math.min(265, state.robotX));
    state.robotY = Math.max(15, Math.min(265, state.robotY));
  }
  
  document.getElementById('speed-display').textContent = state.robotVLin.toFixed(2);
  
  drawSimulator();
  drawSteeringGauge();
  
  requestAnimationFrame(animate);
}

function drawSteeringGauge() {
  const canvas = document.getElementById('steer-gauge');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;
  
  ctx.fillStyle = 'rgba(0, 15, 0, 0.95)';
  ctx.fillRect(0, 0, w, h);
  
  const sections = 9;
  const secWidth = w / sections;
  
  for (let i = 0; i < sections; i++) {
    const x = i * secWidth;
    
    const hazardLevel = steeringGradient.columns[i];
    const a = 0.15 + 0.65 * hazardLevel;
    ctx.fillStyle = `rgba(255, 255, 255, ${a})`;
    ctx.fillRect(x + 1, 4, secWidth - 2, h - 8);
    
    ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x + 0.5, 2);
    ctx.lineTo(x + 0.5, h - 2);
    ctx.stroke();
  }
  
  const steerX = ((state.steerValue + 1) / 2) * w;
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(steerX, 2);
  ctx.lineTo(steerX, h - 2);
  ctx.stroke();
  
  ctx.font = '9px monospace';
  ctx.fillStyle = '#0f0';
  ctx.textAlign = 'left';
  ctx.fillText('Â∑¶', 3, 12);
  ctx.textAlign = 'right';
  ctx.fillText('Âè≥', w - 3, 12);
}

function drawSimulator() {
  const canvas = document.getElementById('robot-sim');
  const ctx = canvas.getContext('2d');
  
  ctx.fillStyle = 'rgba(0, 15, 0, 0.95)';
  ctx.fillRect(0, 0, 280, 280);
  
  ctx.strokeStyle = 'rgba(0, 255, 0, 0.1)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 280; i += 28) {
    ctx.beginPath();
    ctx.moveTo(i, 0);
    ctx.lineTo(i, 280);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, i);
    ctx.lineTo(280, i);
    ctx.stroke();
  }
  
  ctx.font = 'bold 16px monospace';
  ctx.fillStyle = '#0f0';
  ctx.fillText('AI: ' + state.gemmaLastAction, 15, 30);
  
  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fillRect(15, 45, 100, 20);
  ctx.strokeStyle = '#0f0';
  ctx.strokeRect(15, 45, 100, 20);
  
  const fillWidth = (state.lastObstacleScore / 100) * 100;
  ctx.fillStyle = state.lastObstacleScore > 50 ? '#0f0' : state.lastObstacleScore > 20 ? '#ff0' : '#f00';
  ctx.fillRect(15, 45, fillWidth, 20);
  
  ctx.font = '11px monospace';
  ctx.fillStyle = '#0f0';
  ctx.fillText('Ë∑ùÈõ¢: ' + state.lastObstacleScore, 20, 58);
  
  ctx.save();
  ctx.translate(state.robotX, state.robotY);
  ctx.rotate(state.robotTheta);
  
  ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
  ctx.beginPath();
  ctx.arc(0, 0, 12, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  ctx.fillStyle = '#0f0';
  ctx.beginPath();
  ctx.moveTo(0, -12);
  ctx.lineTo(-6, 6);
  ctx.lineTo(6, 6);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
  
  ctx.font = '10px monospace';
  ctx.fillStyle = 'rgba(0, 255, 0, 0.6)';
  ctx.fillText('ÈÄüÂ∫¶: ' + state.robotVLin.toFixed(2), 15, 270);
  ctx.fillText('ËßíÈÄüÂ∫¶: ' + state.robotVAng.toFixed(1), 120, 270);
  
  if (!state.robotEnabled) {
    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
    ctx.font = 'bold 20px monospace';
    ctx.fillText('STOPPED', 70, 140);
  }
}

window.addEventListener('keydown', e => {
  if (e.code === 'KeyM') {
    state.mlEnabled = !state.mlEnabled;
    if (state.mlEnabled) {
      loadML();
      document.getElementById('gemma-status').textContent = 'Ë™≠„ÅøËæº„Åø‰∏≠...';
    } else {
      document.getElementById('gemma-status').textContent = 'ÁÑ°Âäπ';
      document.getElementById('last-decision').textContent = '-';
    }
  }
  
  if (e.code === 'KeyR') {
    state.robotEnabled = !state.robotEnabled;
    const modeEl = document.getElementById('robot-mode');
    modeEl.textContent = state.robotEnabled ? 'Á®ºÂÉç‰∏≠' : 'ÂÅúÊ≠¢‰∏≠';
    modeEl.style.color = state.robotEnabled ? '#0f0' : '#f00';
    
    if (!state.robotEnabled) {
      state.targetVLin = 0;
      state.targetVAng = 0;
      state.robotVLin = 0;
      state.robotVAng = 0;
    }
  }
});

document.getElementById('btn-ai')?.addEventListener('click', () => {
  state.mlEnabled = !state.mlEnabled;
  if (state.mlEnabled) {
    loadML();
    document.getElementById('gemma-status').textContent = 'Ë™≠„ÅøËæº„Åø‰∏≠...';
  } else {
    document.getElementById('gemma-status').textContent = 'ÁÑ°Âäπ';
  }
});

document.getElementById('btn-robot')?.addEventListener('click', () => {
  state.robotEnabled = !state.robotEnabled;
  const modeEl = document.getElementById('robot-mode');
  modeEl.textContent = state.robotEnabled ? 'Á®ºÂÉç‰∏≠' : 'ÂÅúÊ≠¢‰∏≠';
  modeEl.style.color = state.robotEnabled ? '#0f0' : '#f00';
  
  if (!state.robotEnabled) {
    state.targetVLin = 0;
    state.targetVAng = 0;
    state.robotVLin = 0;
    state.robotVAng = 0;
  }
});

document.getElementById('btn-camera')?.addEventListener('click', () => {
  state.debugEdges = !state.debugEdges;
});

let showInfo = false;
document.getElementById('btn-info')?.addEventListener('click', () => {
  showInfo = !showInfo;
  const ui = document.getElementById('ui');
  ui.style.display = showInfo ? 'block' : 'block';
});

cv['onRuntimeInitialized'] = () => {
  navigator.mediaDevices.getUserMedia({ video: true }).then(s => {
    video.srcObject = s;
    video.play();
    
    adjustSimulatorSize();
    
    requestAnimationFrame(animate);
    console.log("System Ready - Press M to enable AI, R to enable Robot");
  });
};

function adjustSimulatorSize() {
  const simCanvas = document.getElementById('robot-sim');
  const steerGauge = document.getElementById('steer-gauge');
  const isMobile = window.innerWidth < 768;
  
  if (!simCanvas) return;
  
  if (isMobile) {
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;
    
    const availableHeight = screenHeight * 0.25;
    const availableWidth = screenWidth;
    
    const maxSize = Math.min(availableWidth * 0.4, availableHeight * 0.9);
    
    simCanvas.width = Math.floor(maxSize);
    simCanvas.height = Math.floor(maxSize);
    simCanvas.style.width = maxSize + 'px';
    simCanvas.style.height = maxSize + 'px';
    
    if (steerGauge) {
      steerGauge.width = screenWidth - maxSize - 4;
      steerGauge.height = 30;
    }
    
    console.log(`Simulator size: ${maxSize}px (Mobile)`);
  } else {
    simCanvas.width = 280;
    simCanvas.height = 280;
    simCanvas.style.width = '280px';
    simCanvas.style.height = '280px';
    
    if (steerGauge) {
      steerGauge.width = 280;
      steerGauge.height = 30;
    }
  }
}

window.addEventListener('resize', () => {
  adjustSimulatorSize();
});
</script>

</body>
</html>
