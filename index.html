<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>A-1 Robot Vision - Smooth Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #0f0;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      touch-action: manipulation;
    }

    /* PC / „Çø„Éñ„É¨„ÉÉ„Éà */
    @media (min-width: 768px) {
      #camera-feed {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      #cv {
        display: block;
        width: 100%;
        height: 100%;
      }

      #ui {
        position: fixed;
        top: 15px;
        left: 15px;
        background: rgba(0, 0, 0, 0.95);
        padding: 15px;
        border: 2px solid #0f0;
        z-index: 100;
        min-width: 280px;
        max-height: 450px;
        overflow-y: auto;
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
      }

      .robot-sim {
        position: fixed;
        bottom: 15px;
        right: 15px;
        border: 3px solid #0f0;
        background: rgba(0, 15, 0, 0.95);
        z-index: 50;
        width: 280px;
        height: 280px;
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
      }

      #steer-gauge {
        position: fixed;
        top: 475px;
        left: 15px;
        width: 280px;
        height: 30px;
        z-index: 50;
        border: 2px solid #0f0;
        background: rgba(0, 0, 0, 0.95);
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
      }

      #keys-info {
        position: fixed;
        bottom: 15px;
        left: 15px;
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #0f0;
        padding: 10px;
        font-size: 11px;
        z-index: 49;
        max-width: 280px;
        display: block;
      }
    }

    /* „Çπ„Éû„Éº„Éà„Éï„Ç©„É≥ */
    @media (max-width: 767px) {
      body {
        font-size: 12px;
      }

      #camera-feed {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 60%;
        z-index: 1;
      }

      #cv {
        display: block;
        width: 100%;
        height: 100%;
      }

      #ui {
        position: fixed;
        top: 60%;
        left: 0;
        right: 0;
        bottom: 60px;
        background: rgba(0, 0, 0, 0.98);
        padding: 10px;
        border-top: 2px solid #0f0;
        z-index: 100;
        overflow-y: auto;
        max-height: calc(40vh - 60px);
      }

      .status-line {
        margin: 4px 0;
        padding: 3px 0;
        font-size: 12px;
      }

      .value {
        min-width: 60px;
        font-size: 12px;
      }

      .robot-sim {
        position: fixed;
        top: 60%;
        right: 0;
        width: 160px;
        height: 160px;
        border: 2px solid #0f0;
        background: rgba(0, 15, 0, 0.95);
        z-index: 50;
        box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
      }

      #steer-gauge {
        position: fixed;
        top: 60%;
        left: 0;
        right: 160px;
        height: 30px;
        z-index: 50;
        border: 2px solid #0f0;
        background: rgba(0, 0, 0, 0.95);
      }

      #keys-info {
        display: none;
      }

      /* „Çø„ÉÉ„ÉÅ„Éú„Çø„É≥ */
      #touch-controls {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 60px;
        background: rgba(0, 0, 0, 0.95);
        border-top: 1px solid #0f0;
        display: flex;
        z-index: 101;
      }

      .touch-btn {
        flex: 1;
        border: 1px solid #0f0;
        background: rgba(0, 30, 0, 0.8);
        color: #0f0;
        font-weight: bold;
        cursor: pointer;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        transition: all 0.1s;
      }

      .touch-btn:active {
        background: rgba(0, 255, 0, 0.3);
        box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.5);
      }

      .touch-btn:hover {
        background: rgba(0, 50, 0, 0.9);
      }
    }

    .status-line {
      margin: 8px 0;
      padding: 5px 0;
      border-bottom: 1px solid #033;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .label {
      flex: 1;
    }

    .value {
      font-weight: bold;
      padding: 0 8px;
      text-align: right;
    }

    .voice-button {
      width: 100%;
      padding: 8px;
      margin-top: 8px;
      border: 1px solid #0f0;
      background: rgba(0, 150, 0, 0.3);
      color: #0f0;
      font-weight: bold;
      cursor: pointer;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      transition: all 0.2s;
    }

    .voice-button:hover {
      background: rgba(0, 200, 0, 0.4);
    }

    .voice-button:active {
      background: rgba(0, 255, 0, 0.2);
    }

    .voice-button.off {
      background: rgba(150, 0, 0, 0.2);
      border-color: #f00;
      color: #f00;
    }

    #video {
      position: fixed;
      left: -10000px;
      opacity: 0;
    }
  </style>
</head>

<body>

  <div id="camera-feed"><canvas id="cv"></canvas></div>

  <div id="ui">
    <div style="margin-bottom: 10px; font-weight: bold; font-size: 16px; text-shadow: 0 0 10px #0f0;">
      ‚öôÔ∏è A-1 ROBOT VISION
    </div>
    <div class="status-line">
      <span class="label">üéØ Obstacle Distance</span>
      <span class="value" id="obs-score">100</span>
    </div>
    <div class="status-line">
      <span class="label">üß† Gemma Brain</span>
      <span class="value" id="gemma-status">Ready</span>
    </div>
    <div class="status-line">
      <span class="label">ü§ñ Robot Status</span>
      <span class="value" id="robot-mode" style="color:#f00">Stopped</span>
    </div>
    <div class="status-line">
      <span class="label">üìç Last Command</span>
      <span class="value" id="last-decision">-</span>
    </div>
    <div class="status-line">
      <span class="label">‚ö° Velocity</span>
      <span class="value" id="speed-display">0.0</span>
    </div>
    <div class="status-line">
      <span class="label">üéØ Steering</span>
      <div class="status-line" style="border-top: 1px solid #144; padding-top: 5px;">
        <span class="label">üõ°Ô∏è Reflex State</span>
        <span class="value" id="reflex-status-text" style="color:#0f0">NORMAL</span>
      </div>

      <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #033;">
        <div style="font-weight: bold; margin-bottom: 8px;">üîä Voice Control</div>

        <div class="status-line">
          <span class="label">ü§ñ Voice Mode</span>
          <span class="value" id="voice-mode-display">Salamander</span>
        </div>

        <div class="status-line">
          <span class="label">üéôÔ∏è Status</span>
          <span class="value" id="speech-status">Ready</span>
        </div>

        <button id="btn-toggle-voice-mode" class="voice-button"
          style="background: rgba(100, 0, 150, 0.3); border-color: #a0f; color: #a0f;">
          üêâ Salamander Mode
        </button>

        <button id="btn-toggle-voice" class="voice-button">
          üîä Voice ON
        </button>

        <button id="btn-stop-voice" class="voice-button">
          ‚è∏ Stop Voice
        </button>
      </div>
    </div>

    <canvas id="steer-gauge" width="280" height="30"></canvas>

    <div id="keys-info">
      <div style="font-weight: bold; margin-bottom: 5px;">Controls</div>
      <div>M key: AI ON/OFF</div>
      <div>R key: Robot ON/OFF</div>
      <div>V key: Voice ON/OFF</div>
    </div>

    <canvas id="robot-sim" class="robot-sim" width="280" height="280"></canvas>
    <video id="video" autoplay playsinline muted></video>

    <!-- Touch Controls -->
    <div id="touch-controls">
      <button class="touch-btn" id="btn-ai">üß† AI</button>
      <button class="touch-btn" id="btn-robot">ü§ñ Motion</button>
      <button class="touch-btn" id="btn-voice">üîä Voice</button>
      <button class="touch-btn" id="btn-info">‚ÑπÔ∏è</button>
    </div>

    <script src="https://docs.opencv.org/4.x/opencv.js"></script>

    <script>
      // ===== Robot Speaker Class (Salamander Style) =====
      class RobotSpeaker {
        constructor() {
          this.synth = window.speechSynthesis;
          this.isSpeaking = false;
          this.voiceMode = 'salamander';  // 'normal' or 'salamander'
        }

        speak(text, options = {}) {
          // Cancel any ongoing speech
          if (this.isSpeaking) {
            this.synth.cancel();
          }

          const utterance = new SpeechSynthesisUtterance(text);

          // Salamander voice settings: cold, precise, authoritative
          utterance.lang = 'en-US';

          if (this.voiceMode === 'salamander') {
            // Salamander: Deep, measured, intimidating
            utterance.rate = 0.7;       // Even slower
            utterance.pitch = 0.6;      // Lower, more authoritative
            utterance.volume = 1.0;     // Full volume
          } else {
            // Normal robot
            utterance.rate = 0.8;
            utterance.pitch = 1.5;
            utterance.volume = 1.0;
          }

          utterance.onstart = () => {
            this.isSpeaking = true;
            console.log(`ü§ñ [${this.voiceMode.toUpperCase()}] Speaking: ${text}`);
            document.getElementById('speech-status').textContent = 'Speaking...';
          };

          utterance.onend = () => {
            this.isSpeaking = false;
            console.log('‚úì Speech complete');
            document.getElementById('speech-status').textContent = 'Ready';
          };

          utterance.onerror = (e) => {
            console.error('Speech error:', e);
            this.isSpeaking = false;
            document.getElementById('speech-status').textContent = 'Error';
          };

          this.synth.speak(utterance);
        }

        stop() {
          this.synth.cancel();
          this.isSpeaking = false;
          document.getElementById('speech-status').textContent = 'Stopped';
        }

        setVoiceMode(mode) {
          this.voiceMode = mode;  // 'salamander' or 'normal'
          console.log(`üéôÔ∏è Voice mode changed to: ${mode.toUpperCase()}`);
        }
      }

      const speaker = new RobotSpeaker();

      // ===== Main State =====
      const state = {
        cvReady: false,
        mlReady: false,
        mlEnabled: false,
        mlInFlight: false,
        lastObstacleScore: 100,
        robotEnabled: false,
        voiceEnabled: true,
        voiceMode: 'salamander',  // 'salamander' or 'normal'

        robotX: 140,
        robotY: 140,
        robotTheta: 0,
        robotVLin: 0,
        robotVAng: 0,
        targetVLin: 0,
        targetVAng: 0,

        gemmaLastAction: 'WAITING',
        gemmaNextAt: 0,
        gemmaThinking: false,

        steerValue: 0,
        steerNextAt: 0
      };

      const video = document.getElementById('video');
      const cvCanvas = document.getElementById('cv');

      async function loadML() {
        if (window.tf && window.cocoSsd) return;

        console.log("Loading TensorFlow.js...");

        try {
          if (!window.tf) {
            await loadScript("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0");
          }
          if (!window.cocoSsd) {
            await loadScript("https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3");
          }
          state.model = await cocoSsd.load();
          state.mlReady = true;
          document.getElementById('gemma-status').textContent = 'Ready';
          console.log("ML Model Ready");
        } catch (e) {
          console.error("ML Load Error:", e);
          document.getElementById('gemma-status').textContent = 'Error';
        }
      }

      function loadScript(src) {
        return new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = src;
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      }

      const capCanvas = document.createElement('canvas');
      const capCtx = capCanvas.getContext('2d', { willReadFrequently: true });

      function runCV() {
        if (!state.cvReady || !video.videoWidth) return;

        capCanvas.width = video.videoWidth;
        capCanvas.height = video.videoHeight;
        capCtx.drawImage(video, 0, 0);

        let src = cv.matFromImageData(capCtx.getImageData(0, 0, video.videoWidth, video.videoHeight));
        let gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        cv.Canny(gray, gray, 50, 100);
        cv.imshow(cvCanvas, gray);

        src.delete();
        gray.delete();
      }

      async function runML() {
        if (!state.mlEnabled || !state.mlReady || state.mlInFlight) return;

        state.mlInFlight = true;

        try {
          const preds = await state.model.detect(capCanvas);

          if (preds.length > 0) {
            let obj = preds.sort((a, b) => b.score - a.score)[0];
            state.lastObstacleScore = Math.max(5, Math.min(100, Math.round(obj.score * 100)));
          } else {
            state.lastObstacleScore = 100;
          }

          document.getElementById('obs-score').textContent = state.lastObstacleScore;

        } catch (e) {
          console.error("ML Error:", e);
        } finally {
          state.mlInFlight = false;
        }
      }

      const steeringGradient = {
        columns: new Float32Array(9),
        bestSteer: 0
      };

      function calculateSteering() {
        const now = performance.now();

        if (now < state.steerNextAt) return;
        state.steerNextAt = now + 200;

        let sum = 0;
        for (let i = 0; i < steeringGradient.columns.length; i++) {
          steeringGradient.columns[i] += (Math.random() - 0.5) * 0.3;
          steeringGradient.columns[i] = Math.max(0, Math.min(1, steeringGradient.columns[i]));
          sum += steeringGradient.columns[i];
        }

        let minIdx = 0;
        let minVal = Infinity;
        for (let i = 0; i < steeringGradient.columns.length; i++) {
          if (steeringGradient.columns[i] < minVal) {
            minVal = steeringGradient.columns[i];
            minIdx = i;
          }
        }

        const mid = (steeringGradient.columns.length - 1) / 2;
        state.steerValue = (minIdx - mid) / mid;

        let steerLabel = '‚Üí Neutral';
        if (state.steerValue < -0.3) {
          steerLabel = '‚Üê Left';
        } else if (state.steerValue > 0.3) {
          steerLabel = 'Right ‚Üí';
        }
        document.getElementById('steer-display').textContent = steerLabel;
      }

      async function askGemma(now) {
        if (!state.robotEnabled || now < state.gemmaNextAt || state.gemmaThinking) return;

        state.gemmaThinking = true;
        state.gemmaNextAt = now + 2500;
        document.getElementById('gemma-status').textContent = 'Thinking...';

        const distance = state.lastObstacleScore;
        console.log("Distance:", distance);

        try {
          const res = await fetch('https://kgninja-functiongemmabotdemo-docker.hf.space/decide', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              front_distance: distance,
              speed: state.robotVLin,
              steer: state.steerValue
            })
          });

          const json = await res.json();
          console.log("API Response:", json);

          let action = null;
          let speech = null;

          if (json.data && json.data[0]) {
            const match = json.data[0].match(/\{.*\}/s);
            if (match) {
              const d = JSON.parse(match[0]);
              action = (d.action || '').toLowerCase();
              speech = d.speech;
              console.log("Parsed action:", action, "Speech:", speech);
            }
          }

          // Fallback speech if not provided
          if (!speech) {
            const speechMap = {
              'move_forward': 'Moving forward',
              'turn_left': 'Turning left to avoid obstacle',
              'turn_right': 'Turning right to avoid obstacle',
              'stop': 'Critical obstacle detected. Stopping.'
            };
            speech = speechMap[action] || 'Executing action';
          }

          // ‚ú® Robot voice output (with mode selection)
          if (state.voiceEnabled && speech) {
            speaker.setVoiceMode(state.voiceMode);
            speaker.speak(speech);
          }

          // Fallback logic if no action from API
          if (!action) {
            console.warn("‚ö†Ô∏è API invalid, using fallback logic");
            if (distance < 30) {
              action = Math.random() > 0.5 ? 'turn_left' : 'turn_right';
            } else if (distance < 60) {
              const actions = ['move_forward', 'turn_left', 'turn_right'];
              action = actions[Math.floor(Math.random() * 3)];
            } else {
              action = 'move_forward';
            }
            console.log("Fallback action:", action);
          }

          state.gemmaLastAction = action.toUpperCase().replace('_', ' ');
          document.getElementById('last-decision').textContent = state.gemmaLastAction;
          document.getElementById('gemma-status').textContent = 'Complete ‚úì';

          if (action === 'move_forward') {
            state.targetVLin = 0.8;
            state.targetVAng = 0;
            console.log("‚Üí FORWARD");
          } else if (action === 'turn_left') {
            state.targetVLin = 0.3;
            state.targetVAng = -2.0;
            console.log("‚Üí LEFT");
          } else if (action === 'turn_right') {
            state.targetVLin = 0.3;
            state.targetVAng = 2.0;
            console.log("‚Üí RIGHT");
          } else {
            state.targetVLin = 0;
            state.targetVAng = 0;
            console.log("‚Üí STOP");
          }

        } catch (e) {
          console.error("Gemma API Error:", e);
          document.getElementById('gemma-status').textContent = 'API Error';

          // Fallback voice
          if (state.voiceEnabled) {
            speaker.speak('Error. Stopping.');
          }

          state.targetVLin = 0;
          state.targetVAng = 0;
        } finally {
          state.gemmaThinking = false;
        }
      }

      function animate(now) {
        if (!state.cvReady && video.videoWidth > 0) {
          cvCanvas.width = 320;
          cvCanvas.height = 240;
          state.cvReady = true;
        }

        runCV();
        runML();
        calculateSteering();

        if (state.mlEnabled) {
          askGemma(now);
        }

        if (state.robotEnabled) {
          state.robotVLin += (state.targetVLin - state.robotVLin) * 0.15;
          state.robotVAng += (state.targetVAng - state.robotVAng) * 0.15;

          state.robotTheta += state.robotVAng * 0.016;
          state.robotX += Math.cos(state.robotTheta) * state.robotVLin * 3;
          state.robotY += Math.sin(state.robotTheta) * state.robotVLin * 3;

          state.robotX = Math.max(15, Math.min(265, state.robotX));
          state.robotY = Math.max(15, Math.min(265, state.robotY));
        }

        document.getElementById('speed-display').textContent = state.robotVLin.toFixed(2);

        drawSimulator();
        drawSteeringGauge();

        requestAnimationFrame(animate);
      }

      function drawSteeringGauge() {
        const canvas = document.getElementById('steer-gauge');
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;

        ctx.fillStyle = 'rgba(0, 15, 0, 0.95)';
        ctx.fillRect(0, 0, w, h);

        const sections = 9;
        const secWidth = w / sections;

        for (let i = 0; i < sections; i++) {
          const x = i * secWidth;

          const hazardLevel = steeringGradient.columns[i];
          const a = 0.15 + 0.65 * hazardLevel;
          ctx.fillStyle = `rgba(255, 255, 255, ${a})`;
          ctx.fillRect(x + 1, 4, secWidth - 2, h - 8);

          ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + 0.5, 2);
          ctx.lineTo(x + 0.5, h - 2);
          ctx.stroke();
        }

        const steerX = ((state.steerValue + 1) / 2) * w;
        ctx.strokeStyle = '#0f0';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(steerX, 2);
        ctx.lineTo(steerX, h - 2);
        ctx.stroke();

        ctx.font = '9px monospace';
        ctx.fillStyle = '#0f0';
        ctx.textAlign = 'left';
        ctx.fillText('Left', 3, 12);
        ctx.textAlign = 'right';
        ctx.fillText('Right', w - 3, 12);
      }

      function drawSimulator() {
        const canvas = document.getElementById('robot-sim');
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = 'rgba(0, 15, 0, 0.95)';
        ctx.fillRect(0, 0, 280, 280);

        ctx.strokeStyle = 'rgba(0, 255, 0, 0.1)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 280; i += 28) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, 280);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, i);
          ctx.lineTo(280, i);
          ctx.stroke();
        }

        ctx.font = 'bold 16px monospace';
        ctx.fillStyle = '#0f0';
        ctx.fillText('AI: ' + state.gemmaLastAction, 15, 30);

        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(15, 45, 100, 20);
        ctx.strokeStyle = '#0f0';
        ctx.strokeRect(15, 45, 100, 20);

        const fillWidth = (state.lastObstacleScore / 100) * 100;
        ctx.fillStyle = state.lastObstacleScore > 50 ? '#0f0' : state.lastObstacleScore > 20 ? '#ff0' : '#f00';
        ctx.fillRect(15, 45, fillWidth, 20);

        ctx.font = '11px monospace';
        ctx.fillStyle = '#0f0';
        ctx.fillText('Distance: ' + state.lastObstacleScore, 20, 58);

        ctx.save();
        ctx.translate(state.robotX, state.robotY);
        ctx.rotate(state.robotTheta);

        ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
        ctx.beginPath();
        ctx.arc(0, 0, 12, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#0f0';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = '#0f0';
        ctx.beginPath();
        ctx.moveTo(0, -12);
        ctx.lineTo(-6, 6);
        ctx.lineTo(6, 6);
        ctx.closePath();
        ctx.fill();

        ctx.restore();

        ctx.font = '10px monospace';
        ctx.fillStyle = 'rgba(0, 255, 0, 0.6)';
        ctx.fillText('Velocity: ' + state.robotVLin.toFixed(2), 15, 270);
        ctx.fillText('Angular: ' + state.robotVAng.toFixed(1), 120, 270);

        if (!state.robotEnabled) {
          ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
          ctx.font = 'bold 20px monospace';
          ctx.fillText('STOPPED', 70, 140);
        }
      }

      // ===== Keyboard Controls =====
      window.addEventListener('keydown', e => {
        if (e.code === 'KeyM') {
          state.mlEnabled = !state.mlEnabled;
          if (state.mlEnabled) {
            loadML();
            document.getElementById('gemma-status').textContent = 'Loading...';
          } else {
            document.getElementById('gemma-status').textContent = 'Disabled';
            document.getElementById('last-decision').textContent = '-';
          }
        }

        if (e.code === 'KeyR') {
          state.robotEnabled = !state.robotEnabled;
          const modeEl = document.getElementById('robot-mode');
          modeEl.textContent = state.robotEnabled ? 'Running' : 'Stopped';
          modeEl.style.color = state.robotEnabled ? '#0f0' : '#f00';

          if (!state.robotEnabled) {
            state.targetVLin = 0;
            state.targetVAng = 0;
            state.robotVLin = 0;
            state.robotVAng = 0;
          }
        }

        if (e.code === 'KeyV') {
          state.voiceEnabled = !state.voiceEnabled;
          const btn = document.getElementById('btn-toggle-voice');
          btn.textContent = state.voiceEnabled ? 'üîä Voice ON' : 'üîá Voice OFF';
          btn.classList.toggle('off');
        }
      });

      // ===== Touch Button Controls =====
      document.getElementById('btn-ai')?.addEventListener('click', () => {
        state.mlEnabled = !state.mlEnabled;
        if (state.mlEnabled) {
          loadML();
          document.getElementById('gemma-status').textContent = 'Loading...';
        } else {
          document.getElementById('gemma-status').textContent = 'Disabled';
        }
      });

      document.getElementById('btn-robot')?.addEventListener('click', () => {
        state.robotEnabled = !state.robotEnabled;
        const modeEl = document.getElementById('robot-mode');
        modeEl.textContent = state.robotEnabled ? 'Running' : 'Stopped';
        modeEl.style.color = state.robotEnabled ? '#0f0' : '#f00';

        if (!state.robotEnabled) {
          state.targetVLin = 0;
          state.targetVAng = 0;
          state.robotVLin = 0;
          state.robotVAng = 0;
        }
      });

      document.getElementById('btn-toggle-voice-mode')?.addEventListener('click', () => {
        state.voiceMode = state.voiceMode === 'salamander' ? 'normal' : 'salamander';
        speaker.setVoiceMode(state.voiceMode);

        const btn = document.getElementById('btn-toggle-voice-mode');
        const display = document.getElementById('voice-mode-display');

        if (state.voiceMode === 'salamander') {
          btn.textContent = 'üêâ Salamander Mode';
          btn.style.background = 'rgba(100, 0, 150, 0.3)';
          btn.style.borderColor = '#a0f';
          btn.style.color = '#a0f';
          display.textContent = 'Salamander';
        } else {
          btn.textContent = 'ü§ñ Normal Robot';
          btn.style.background = 'rgba(0, 150, 0, 0.3)';
          btn.style.borderColor = '#0f0';
          btn.style.color = '#0f0';
          display.textContent = 'Normal';
        }
      });

      document.getElementById('btn-toggle-voice')?.addEventListener('click', () => {
        state.voiceEnabled = !state.voiceEnabled;
        const btn = document.getElementById('btn-toggle-voice');
        btn.textContent = state.voiceEnabled ? 'üîä Voice ON' : 'üîá Voice OFF';
        btn.classList.toggle('off');
      });

      document.getElementById('btn-stop-voice')?.addEventListener('click', () => {
        speaker.stop();
      });

      let showInfo = false;
      document.getElementById('btn-info')?.addEventListener('click', () => {
        showInfo = !showInfo;
        const ui = document.getElementById('ui');
        ui.style.display = showInfo ? 'block' : 'block';
      });

      cv['onRuntimeInitialized'] = () => {
        navigator.mediaDevices.getUserMedia({ video: true }).then(s => {
          video.srcObject = s;
          video.play();

          adjustSimulatorSize();

          requestAnimationFrame(animate);
          console.log("System Ready - Press M for AI, R for Robot, V for Voice");
        });
      };

      function adjustSimulatorSize() {
        const simCanvas = document.getElementById('robot-sim');
        const steerGauge = document.getElementById('steer-gauge');
        const isMobile = window.innerWidth < 768;

        if (!simCanvas) return;

        if (isMobile) {
          const screenWidth = window.innerWidth;
          const screenHeight = window.innerHeight;

          const availableHeight = screenHeight * 0.25;
          const availableWidth = screenWidth;

          const maxSize = Math.min(availableWidth * 0.4, availableHeight * 0.9);

          simCanvas.width = Math.floor(maxSize);
          simCanvas.height = Math.floor(maxSize);
          simCanvas.style.width = maxSize + 'px';
          simCanvas.style.height = maxSize + 'px';

          if (steerGauge) {
            steerGauge.width = screenWidth - maxSize - 4;
            steerGauge.height = 30;
          }

          console.log(`Simulator size: ${maxSize}px (Mobile)`);
        } else {
          simCanvas.width = 280;
          simCanvas.height = 280;
          simCanvas.style.width = '280px';
          simCanvas.style.height = '280px';

          if (steerGauge) {
            steerGauge.width = 280;
            steerGauge.height = 30;
          }
        }
      }

      window.addEventListener('resize', () => {
        adjustSimulatorSize();
      });
    </script>

</body>

</html>