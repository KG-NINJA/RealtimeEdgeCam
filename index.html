<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>A-1 Robot Vision - Smooth Control</title>
<style>
* { box-sizing: border-box; }
body { 
  margin: 0; padding: 0; 
  background: #000; color: #0f0; 
  font-family: 'Courier New', monospace; 
  font-size: 14px; 
  overflow: hidden; 
  width: 100vw; height: 100vh; 
}
#camera-feed { 
  position: absolute; top: 0; left: 0; 
  width: 100%; height: 100%; 
  z-index: 1; 
}
#cv { display: block; width: 100%; height: 100%; }
#ui { 
  position: fixed; top: 15px; left: 15px; 
  background: rgba(0, 0, 0, 0.95); 
  padding: 15px; 
  border: 2px solid #0f0; 
  z-index: 100;
  min-width: 280px;
  box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
}
.status-line { 
  margin: 8px 0; 
  padding: 5px 0;
  border-bottom: 1px solid #033; 
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.label { flex: 1; }
.value { 
  font-weight: bold; 
  padding: 0 8px;
  min-width: 80px;
  text-align: right;
}
.robot-sim { 
  position: fixed; 
  bottom: 15px; right: 15px; 
  border: 3px solid #0f0; 
  background: rgba(0, 15, 0, 0.95); 
  z-index: 50;
  box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
}
#video { position: fixed; left: -10000px; opacity: 0; }
.robot-body {
  position: relative;
  width: 100%;
  height: 100%;
}
.direction-indicator {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 30px;
  height: 40px;
  border: 2px solid #0f0;
  border-radius: 15px 15px 5px 5px;
}
.direction-arrow {
  position: absolute;
  top: 5px;
  left: 50%;
  transform: translateX(-50%);
  width: 0;
  height: 0;
  border-left: 8px solid transparent;
  border-right: 8px solid transparent;
  border-bottom: 12px solid #0f0;
}
.info-text {
  position: absolute;
  bottom: 10px;
  left: 10px;
  font-size: 11px;
  line-height: 1.4;
}
.action-label {
  position: absolute;
  top: 10px;
  left: 10px;
  font-size: 13px;
  font-weight: bold;
  color: #0f0;
  text-shadow: 0 0 5px #0f0;
}
.distance-bar {
  position: absolute;
  bottom: 10px;
  right: 10px;
  width: 80px;
  height: 15px;
  border: 1px solid #0f0;
  background: #001;
}
.distance-fill {
  height: 100%;
  background: #0f0;
  transition: width 0.3s ease;
}
#keys-info {
  position: fixed;
  bottom: 15px;
  left: 15px;
  background: rgba(0, 0, 0, 0.95);
  border: 2px solid #0f0;
  padding: 10px;
  font-size: 12px;
  z-index: 50;
  box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
}
</style>
</head>
<body>

<div id="camera-feed"><canvas id="cv"></canvas></div>

<div id="ui">
  <div style="margin-bottom: 10px; font-weight: bold; font-size: 16px; text-shadow: 0 0 10px #0f0;">
    âš™ï¸ A-1 ROBOT VISION
  </div>
  <div class="status-line">
    <span class="label">ğŸ¯ éšœå®³ç‰©è·é›¢</span>
    <span class="value" id="obs-score">100</span>
  </div>
  <div class="status-line">
    <span class="label">ğŸ§  Gemmaæ€è€ƒ</span>
    <span class="value" id="gemma-status">å¾…æ©Ÿä¸­</span>
  </div>
  <div class="status-line">
    <span class="label">ğŸ¤– ãƒ­ãƒœãƒƒãƒˆçŠ¶æ…‹</span>
    <span class="value" id="robot-mode" style="color:#f00">åœæ­¢ä¸­</span>
  </div>
  <div class="status-line">
    <span class="label">ğŸ“ ç¾åœ¨ã®æŒ‡ç¤º</span>
    <span class="value" id="last-decision">-</span>
  </div>
  <div class="status-line">
    <span class="label">âš¡ é€Ÿåº¦</span>
    <span class="value" id="speed-display">0.0</span>
  </div>
</div>

<div id="keys-info">
  <div style="font-weight: bold; margin-bottom: 5px;">æ“ä½œã‚­ãƒ¼</div>
  <div>M ã‚­ãƒ¼: AIèªè­˜ ON/OFF</div>
  <div>R ã‚­ãƒ¼: ãƒ­ãƒœãƒƒãƒˆå‹•ä½œ ON/OFF</div>
</div>

<canvas id="robot-sim" class="robot-sim" width="280" height="280"></canvas>
<video id="video" autoplay playsinline muted></video>

<script src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
const state = {
  cvReady: false,
  mlReady: false,
  mlEnabled: false,
  mlInFlight: false,
  lastObstacleScore: 100,
  robotEnabled: false,
  
  // ãƒ­ãƒœãƒƒãƒˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã®çŠ¶æ…‹
  robotX: 140,
  robotY: 140,
  robotTheta: 0,
  robotVLin: 0,
  robotVAng: 0,
  targetVLin: 0,
  targetVAng: 0,
  
  // Gemma AIã®çŠ¶æ…‹
  gemmaLastAction: 'WAITING',
  gemmaNextAt: 0,
  gemmaThinking: false
};

const video = document.getElementById('video');
const cvCanvas = document.getElementById('cv');

/* TensorFlow.js ã¨ COCO-SSD ã®èª­ã¿è¾¼ã¿ */
async function loadML() {
  if (window.tf && window.cocoSsd) return;
  
  console.log("Loading TensorFlow.js...");
  
  try {
    if (!window.tf) {
      await loadScript("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0");
    }
    if (!window.cocoSsd) {
      await loadScript("https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3");
    }
    state.model = await cocoSsd.load();
    state.mlReady = true;
    document.getElementById('gemma-status').textContent = 'æº–å‚™å®Œäº†';
    console.log("ML Model Ready");
  } catch (e) {
    console.error("ML Load Error:", e);
    document.getElementById('gemma-status').textContent = 'ã‚¨ãƒ©ãƒ¼';
  }
}

function loadScript(src) {
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = src;
    s.onload = resolve;
    s.onerror = reject;
    document.head.appendChild(s);
  });
}

/* OpenCVå‡¦ç† */
const capCanvas = document.createElement('canvas');
const capCtx = capCanvas.getContext('2d', { willReadFrequently: true });

function runCV() {
  if (!state.cvReady || !video.videoWidth) return;
  
  capCanvas.width = video.videoWidth;
  capCanvas.height = video.videoHeight;
  capCtx.drawImage(video, 0, 0);
  
  let src = cv.matFromImageData(capCtx.getImageData(0, 0, video.videoWidth, video.videoHeight));
  let gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.Canny(gray, gray, 50, 100);
  cv.imshow(cvCanvas, gray);
  
  src.delete();
  gray.delete();
}

async function runML() {
  if (!state.mlEnabled || !state.mlReady || state.mlInFlight) return;
  
  state.mlInFlight = true;
  
  try {
    const preds = await state.model.detect(capCanvas);
    
    if (preds.length > 0) {
      let obj = preds.sort((a, b) => b.score - a.score)[0];
      // ã‚¹ã‚³ã‚¢: é«˜ã„ = è¿‘ã„ã€‚ã‚¹ã‚³ã‚¢ã‚’è·é›¢(5~100)ã«å¤‰æ›
      state.lastObstacleScore = Math.max(5, Math.min(100, Math.round(obj.score * 100)));
    } else {
      state.lastObstacleScore = 100; // ä½•ã‚‚è¦‹ãˆãªã„ = é ã„
    }
    
    document.getElementById('obs-score').textContent = state.lastObstacleScore;
    
  } catch (e) {
    console.error("ML Error:", e);
  } finally {
    state.mlInFlight = false;
  }
}

/* Gemma AI ã¸ã®å•ã„åˆã‚ã› */
async function askGemma(now) {
  if (!state.robotEnabled || now < state.gemmaNextAt || state.gemmaThinking) return;
  
  state.gemmaThinking = true;
  state.gemmaNextAt = now + 2500; // 2.5ç§’ã”ã¨ã«åˆ¤å®š
  document.getElementById('gemma-status').textContent = 'æ€è€ƒä¸­...';
  
  // è·é›¢ã‚’5-100ã«ãƒãƒƒãƒ”ãƒ³ã‚°
  const distance = state.lastObstacleScore;
  console.log("=== Gemma API Call ===");
  console.log("Distance:", distance);
  
  try {
    const res = await fetch('https://kgninja-functiongemmabotdemo-docker.hf.space/decide', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        front_distance: distance,
        speed: state.robotVLin
      })
    });
    
    const json = await res.json();
    console.log("API Response:", json);
    
    const match = json.data[0].match(/\{.*\}/s);
    console.log("Match result:", match);
    
    if (match) {
      const d = JSON.parse(match[0]);
      console.log("Parsed JSON:", d);
      
      state.gemmaLastAction = (d.action || 'STOP').toUpperCase();
      document.getElementById('last-decision').textContent = state.gemmaLastAction;
      document.getElementById('gemma-status').textContent = 'å®Œäº† âœ“';
      
      console.log("Gemma Action:", state.gemmaLastAction);
      
      if (state.gemmaLastAction.includes('FORWARD')) {
        state.targetVLin = 0.8;
        state.targetVAng = 0;
        console.log("â†’ FORWARD");
      } else if (state.gemmaLastAction.includes('LEFT') || state.gemmaLastAction.includes('turn_left')) {
        state.targetVLin = 0.3;
        state.targetVAng = 2.0; // å·¦å›è»¢
        console.log("â†’ LEFT");
      } else if (state.gemmaLastAction.includes('RIGHT') || state.gemmaLastAction.includes('turn_right')) {
        state.targetVLin = 0.3;
        state.targetVAng = -2.0; // å³å›è»¢
        console.log("â†’ RIGHT");
      } else {
        state.targetVLin = 0;
        state.targetVAng = 0;
        console.log("â†’ STOP");
      }
    } else {
      console.warn("No JSON match found in API response");
    }
  } catch (e) {
    console.error("Gemma API Error:", e);
    document.getElementById('gemma-status').textContent = 'APIå¤±æ•—';
    state.targetVLin = 0;
    state.targetVAng = 0;
  } finally {
    state.gemmaThinking = false;
  }
}

/* ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ— */
function animate(now) {
  // OpenCVåˆæœŸåŒ–
  if (!state.cvReady && video.videoWidth > 0) {
    cvCanvas.width = 320;
    cvCanvas.height = 240;
    state.cvReady = true;
  }
  
  // ã‚»ãƒ³ã‚µãƒ¼å‡¦ç†
  runCV();
  runML();
  
  // AIåˆ¤å®š
  if (state.mlEnabled) {
    askGemma(now);
  }
  
  // ãƒ­ãƒœãƒƒãƒˆç‰©ç†æ¼”ç®—ï¼ˆã‚¹ãƒ ãƒ¼ã‚ºãªåŠ é€Ÿåº¦ï¼‰
  if (state.robotEnabled) {
    // é€Ÿåº¦ã‚’å¾ã€…ã«ç›®æ¨™é€Ÿåº¦ã«è¿‘ã¥ã‘ã‚‹
    state.robotVLin += (state.targetVLin - state.robotVLin) * 0.15;
    state.robotVAng += (state.targetVAng - state.robotVAng) * 0.15;
    
    // ä½ç½®ã¨æ–¹å‘ã®æ›´æ–°
    state.robotTheta += state.robotVAng * 0.016; // deltaTimeç´„16ms
    state.robotX += Math.cos(state.robotTheta) * state.robotVLin * 3;
    state.robotY += Math.sin(state.robotTheta) * state.robotVLin * 3;
    
    // å¢ƒç•Œå‡¦ç†
    state.robotX = Math.max(15, Math.min(265, state.robotX));
    state.robotY = Math.max(15, Math.min(265, state.robotY));
  }
  
  // é€Ÿåº¦è¡¨ç¤ºã‚’æ›´æ–°
  document.getElementById('speed-display').textContent = state.robotVLin.toFixed(2);
  
  // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿æç”»
  drawSimulator();
  
  requestAnimationFrame(animate);
}

function drawSimulator() {
  const canvas = document.getElementById('robot-sim');
  const ctx = canvas.getContext('2d');
  
  // èƒŒæ™¯
  ctx.fillStyle = 'rgba(0, 15, 0, 0.95)';
  ctx.fillRect(0, 0, 280, 280);
  
  // ã‚°ãƒªãƒƒãƒ‰ï¼ˆå‚è€ƒç·šï¼‰
  ctx.strokeStyle = 'rgba(0, 255, 0, 0.1)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 280; i += 28) {
    ctx.beginPath();
    ctx.moveTo(i, 0);
    ctx.lineTo(i, 280);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, i);
    ctx.lineTo(280, i);
    ctx.stroke();
  }
  
  // AIæŒ‡ç¤ºãƒ†ã‚­ã‚¹ãƒˆ
  ctx.font = 'bold 16px monospace';
  ctx.fillStyle = '#0f0';
  ctx.fillText('AI: ' + state.gemmaLastAction, 15, 30);
  
  // è·é›¢ã‚²ãƒ¼ã‚¸
  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fillRect(15, 45, 100, 20);
  ctx.strokeStyle = '#0f0';
  ctx.strokeRect(15, 45, 100, 20);
  
  const fillWidth = (state.lastObstacleScore / 100) * 100;
  ctx.fillStyle = state.lastObstacleScore > 50 ? '#0f0' : state.lastObstacleScore > 20 ? '#ff0' : '#f00';
  ctx.fillRect(15, 45, fillWidth, 20);
  
  ctx.font = '11px monospace';
  ctx.fillStyle = '#0f0';
  ctx.fillText('è·é›¢: ' + state.lastObstacleScore, 20, 58);
  
  // ãƒ­ãƒœãƒƒãƒˆæœ¬ä½“
  ctx.save();
  ctx.translate(state.robotX, state.robotY);
  ctx.rotate(state.robotTheta);
  
  // ãƒ­ãƒœãƒƒãƒˆãƒœãƒ‡ã‚£ï¼ˆå††å½¢ï¼‰
  ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
  ctx.beginPath();
  ctx.arc(0, 0, 12, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // å‰æ–¹æŒ‡ç¤ºï¼ˆä¸‰è§’å½¢ï¼‰
  ctx.fillStyle = '#0f0';
  ctx.beginPath();
  ctx.moveTo(0, -12);
  ctx.lineTo(-6, 6);
  ctx.lineTo(6, 6);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
  
  // æƒ…å ±ãƒ†ã‚­ã‚¹ãƒˆ
  ctx.font = '10px monospace';
  ctx.fillStyle = 'rgba(0, 255, 0, 0.6)';
  ctx.fillText('é€Ÿåº¦: ' + state.robotVLin.toFixed(2), 15, 270);
  ctx.fillText('è§’é€Ÿåº¦: ' + state.robotVAng.toFixed(1), 120, 270);
  
  // ãƒ­ãƒœãƒƒãƒˆçŠ¶æ…‹
  if (!state.robotEnabled) {
    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
    ctx.font = 'bold 20px monospace';
    ctx.fillText('STOPPED', 70, 140);
  }
}

/* ã‚­ãƒ¼å…¥åŠ› */
window.addEventListener('keydown', e => {
  if (e.code === 'KeyM') {
    state.mlEnabled = !state.mlEnabled;
    if (state.mlEnabled) {
      loadML();
      document.getElementById('gemma-status').textContent = 'èª­ã¿è¾¼ã¿ä¸­...';
    } else {
      document.getElementById('gemma-status').textContent = 'ç„¡åŠ¹';
      document.getElementById('last-decision').textContent = '-';
    }
  }
  
  if (e.code === 'KeyR') {
    state.robotEnabled = !state.robotEnabled;
    const modeEl = document.getElementById('robot-mode');
    modeEl.textContent = state.robotEnabled ? 'ç¨¼åƒä¸­' : 'åœæ­¢ä¸­';
    modeEl.style.color = state.robotEnabled ? '#0f0' : '#f00';
    
    if (!state.robotEnabled) {
      state.targetVLin = 0;
      state.targetVAng = 0;
      state.robotVLin = 0;
      state.robotVAng = 0;
    }
  }
});

/* èµ·å‹• */
cv['onRuntimeInitialized'] = () => {
  navigator.mediaDevices.getUserMedia({ video: true }).then(s => {
    video.srcObject = s;
    video.play();
    requestAnimationFrame(animate);
    console.log("System Ready - Press M to enable AI, R to enable Robot");
  });
};
</script>

</body>
</html>
