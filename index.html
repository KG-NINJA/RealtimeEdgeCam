<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>A-1 Poodle Robot â€“ Steering + Edge</title>

<style>
body { margin:0; background:#000; color:#0f0; font-family:monospace; overflow:hidden; }
#ui {
  position:fixed; top:10px; left:10px;
  background:rgba(0,0,0,0.9);
  border:2px solid #0f0;
  padding:10px;
  z-index:100;
  min-width:260px;
}
.line { display:flex; justify-content:space-between; margin:4px 0; }
canvas { position:absolute; inset:0; width:100vw; height:100vh; }
video { position:fixed; left:-9999px; }
</style>
</head>

<body>

<canvas id="view"></canvas>

<div id="ui">
  <b>ğŸ© A-1 POODLE ROBOT</b>
  <div class="line"><span>Edgeè·é›¢</span><span id="dist">100</span></div>
  <div class="line"><span>é€Ÿåº¦ v</span><span id="vlin">0.0</span></div>
  <div class="line"><span>è§’é€Ÿåº¦ Ï‰</span><span id="vang">0.0</span></div>
  <div class="line"><span>æ„Ÿæƒ…</span><span id="emotion">ğŸ© ã†ã‚Œã—ã„ï¼</span></div>
</div>

<video id="video" autoplay playsinline muted></video>

<script src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
/* ======================
   STATE
====================== */
const state = {
  lastObstacleScore: 100,
  robotVLin: 0,
  robotVAng: 0,
  targetVLin: 0,
  targetVAng: 0,

  emotionBase:'happy',
  emotionOverlay:null,
  emotionOverlayUntil:0,
  emotionState:'happy',
  emotionIntensity:0.7,
  emotionNextUpdate:0
};

const video = document.getElementById("video");
const canvas = document.getElementById("view");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;

/* ======================
   CAMERA
====================== */
navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}})
  .then(s => { video.srcObject = s; });

/* ======================
   EDGE DETECTION
====================== */
let src, gray, edges;

function processEdge() {
  if (!cv || video.readyState < 2) return;

  if (!src) {
    src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
    gray = new cv.Mat();
    edges = new cv.Mat();
  }

  ctx.drawImage(video,0,0,canvas.width,canvas.height);
  let imgData = ctx.getImageData(0,0,video.videoWidth,video.videoHeight);
  src.data.set(imgData.data);

  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.Canny(gray, edges, 80, 150);

  // å‰æ–¹ä¸­å¤®é ˜åŸŸã®ã‚¨ãƒƒã‚¸å¯†åº¦
  const cx = Math.floor(edges.cols/2);
  const w = Math.floor(edges.cols*0.2);
  let edgeCount = 0;
  for(let y=edges.rows*0.4;y<edges.rows*0.6;y++){
    for(let x=cx-w;x<cx+w;x++){
      if(edges.ucharPtr(y,x)[0]>0) edgeCount++;
    }
  }

  state.lastObstacleScore = Math.max(0,100 - edgeCount/80);
  document.getElementById("dist").textContent = state.lastObstacleScore.toFixed(0);

  // æç”»ï¼ˆãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ é¢¨ï¼‰
  ctx.globalAlpha=0.6;
  ctx.drawImage(edges,0,0,canvas.width,canvas.height);
  ctx.globalAlpha=1;
}

/* ======================
   STEERING
====================== */
function updateSteering(){
  const d = state.lastObstacleScore;

  if(d < 30){
    state.targetVLin = 0.1;
    state.targetVAng = 0.8;   // å›é¿æ—‹å›
  } else if(d < 60){
    state.targetVLin = 0.3;
    state.targetVAng = 0.3;
  } else {
    state.targetVLin = 0.6;
    state.targetVAng = 0.0;
  }

  // æ…£æ€§ï¼ˆãªã¤ã£ã“ã„å‹•ãï¼‰
  state.robotVLin += (state.targetVLin - state.robotVLin)*0.05;
  state.robotVAng += (state.targetVAng - state.robotVAng)*0.05;

  document.getElementById("vlin").textContent = state.robotVLin.toFixed(2);
  document.getElementById("vang").textContent = state.robotVAng.toFixed(2);
}

/* ======================
   ğŸ© POODLE EMOTION
====================== */
function updateEmotion(){
  const now = performance.now();
  if(now < state.emotionNextUpdate) return;
  state.emotionNextUpdate = now + 300;

  const d = state.lastObstacleScore;
  const fast = state.robotVLin > 0.5;
  const safe = d > 60;

  if(fast && d>80){
    state.emotionBase='excited';
  } else if(safe){
    state.emotionBase='happy';
  } else {
    state.emotionBase='curious';
  }

  if(d<30){
    state.emotionOverlay='alert';
    state.emotionOverlayUntil=now+600;
  }

  if(state.emotionOverlay && now>state.emotionOverlayUntil){
    state.emotionOverlay=null;
  }

  state.emotionState = state.emotionOverlay || state.emotionBase;

  document.getElementById("emotion").textContent = {
    excited:'ğŸ©âœ¨ ãŸã®ã—ã„ï¼',
    happy:'ğŸ© ã†ã‚Œã—ã„ï¼',
    curious:'ğŸ©ï¼Ÿ ãªã«ãªã«ï¼Ÿ',
    alert:'ğŸ©ï¼ ã¡ã‚‡ã£ã¨å¾…ã£ã¦'
  }[state.emotionState];
}

/* ======================
   LOOP
====================== */
function loop(){
  processEdge();
  updateSteering();
  updateEmotion();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>

</body>
</html>
