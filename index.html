<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>A-1 Robot Vision - Smooth Control</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<style>
* { box-sizing: border-box; }
body { 
  margin: 0; padding: 0; 
  background: #000; color: #0f0; 
  font-family: 'Courier New', monospace; 
  font-size: 14px; 
  overflow: hidden; 
  width: 100vw; height: 100vh;
  touch-action: manipulation;
}

/* PC / ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆ */
@media (min-width: 768px) {
  #camera-feed { 
    position: absolute; top: 0; left: 0; 
    width: 100%; height: 100%; 
    z-index: 1; 
  }
  #cv { display: block; width: 100%; height: 100%; }
  
  #ui { 
    position: fixed; top: 15px; left: 15px; 
    background: rgba(0, 0, 0, 0.95); 
    padding: 15px; 
    border: 2px solid #0f0; 
    z-index: 100;
    min-width: 280px;
    max-height: 500px;
    overflow-y: auto;
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
  }
  
  .robot-sim { 
    position: fixed; 
    bottom: 15px; right: 15px; 
    border: 3px solid #0f0; 
    background: rgba(0, 15, 0, 0.95); 
    z-index: 50;
    width: 280px;
    height: 280px;
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
  }
  
  #steer-gauge {
    position: fixed;
    top: 310px;
    left: 15px;
    width: 280px;
    height: 40px;
    z-index: 50;
  }
  
  #keys-info {
    position: fixed;
    bottom: 15px;
    left: 15px;
    background: rgba(0, 0, 0, 0.95);
    border: 2px solid #0f0;
    padding: 10px;
    font-size: 11px;
    z-index: 49;
    max-width: 280px;
    display: block;
  }
}

/* ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ */
@media (max-width: 767px) {
  body { font-size: 12px; }
  
  #camera-feed { 
    position: absolute; top: 0; left: 0; 
    width: 100%; height: 60%; 
    z-index: 1; 
  }
  #cv { display: block; width: 100%; height: 100%; }
  
  #ui { 
    position: fixed; 
    top: 60%; left: 0; right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.98); 
    padding: 10px; 
    border-top: 2px solid #0f0;
    z-index: 100;
    overflow-y: auto;
    max-height: 40vh;
  }
  
  .status-line { 
    margin: 4px 0; 
    padding: 3px 0;
    font-size: 12px;
  }
  
  .value { 
    min-width: 60px;
    font-size: 12px;
  }
  
  .robot-sim { 
    position: fixed; 
    top: 60%; right: 0;
    width: 160px;
    height: 160px;
    border: 2px solid #0f0; 
    background: rgba(0, 15, 0, 0.95); 
    z-index: 50;
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
  }
  
  #steer-gauge {
    position: fixed;
    top: 60%;
    left: 0;
    right: 160px;
    height: 60px;
    z-index: 50;
  }
  
  #keys-info {
    display: none; /* ã‚¹ãƒãƒ›ã§ã¯éè¡¨ç¤º */
  }
  
  /* ã‚¿ãƒƒãƒãƒœã‚¿ãƒ³ */
  #touch-controls {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 60px;
    background: rgba(0, 0, 0, 0.95);
    border-top: 1px solid #0f0;
    display: flex;
    z-index: 101;
  }
  
  .touch-btn {
    flex: 1;
    border: 1px solid #0f0;
    background: rgba(0, 30, 0, 0.8);
    color: #0f0;
    font-weight: bold;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    transition: all 0.1s;
  }
  
  .touch-btn:active {
    background: rgba(0, 255, 0, 0.3);
    box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.5);
  }
  
  .touch-btn:hover {
    background: rgba(0, 50, 0, 0.9);
  }
}

.status-line { 
  margin: 8px 0; 
  padding: 5px 0;
  border-bottom: 1px solid #033; 
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.label { flex: 1; }
.value { 
  font-weight: bold; 
  padding: 0 8px;
  text-align: right;
}
#video { position: fixed; left: -10000px; opacity: 0; }
</style>
</head>
<body>

<div id="camera-feed"><canvas id="cv"></canvas></div>

<div id="ui">
  <div style="margin-bottom: 10px; font-weight: bold; font-size: 16px; text-shadow: 0 0 10px #0f0;">
    âš™ï¸ A-1 ROBOT VISION
  </div>
  <div class="status-line">
    <span class="label">ğŸ¯ éšœå®³ç‰©è·é›¢</span>
    <span class="value" id="obs-score">100</span>
  </div>
  <div class="status-line">
    <span class="label">ğŸ§  Gemmaæ€è€ƒ</span>
    <span class="value" id="gemma-status">å¾…æ©Ÿä¸­</span>
  </div>
  <div class="status-line">
    <span class="label">ğŸ¤– ãƒ­ãƒœãƒƒãƒˆçŠ¶æ…‹</span>
    <span class="value" id="robot-mode" style="color:#f00">åœæ­¢ä¸­</span>
  </div>
  <div class="status-line">
    <span class="label">ğŸ“ ç¾åœ¨ã®æŒ‡ç¤º</span>
    <span class="value" id="last-decision">-</span>
  </div>
  <div class="status-line">
    <span class="label">âš¡ é€Ÿåº¦</span>
    <span class="value" id="speed-display">0.0</span>
  </div>
  <div class="status-line">
    <span class="label">ğŸ¯ ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°</span>
    <span class="value" id="steer-display">â†’ ä¸­ç«‹</span>
  </div>
  <div class="status-line">
    <span class="label" style="flex: 1;">ğŸ’­ æ„Ÿæƒ…çŠ¶æ…‹</span>
    <span class="value" id="emotion-display" style="font-size: 16px;">ğŸ˜ å¹³é™</span>
  </div>
</div>

<div style="position: fixed; top: 310px; left: 15px; width: 280px; height: 40px; background: rgba(0, 0, 0, 0.95); border: 2px solid #0f0; z-index: 50; box-shadow: 0 0 20px rgba(0, 255, 0, 0.3); display: none;" id="emotion-bar-pc">
  <canvas id="emotion-gauge" width="280" height="40" style="display: block; width: 100%; height: 100%;"></canvas>
</div>

<div id="keys-info">
  <div style="font-weight: bold; margin-bottom: 5px;">æ“ä½œã‚­ãƒ¼</div>
  <div>M ã‚­ãƒ¼: AIèªè­˜ ON/OFF</div>
  <div>R ã‚­ãƒ¼: ãƒ­ãƒœãƒƒãƒˆå‹•ä½œ ON/OFF</div>
</div>

<canvas id="robot-sim" class="robot-sim" width="280" height="280"></canvas>
<video id="video" autoplay playsinline muted></video>

<!-- ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ç”¨ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
<div id="touch-controls">
  <button class="touch-btn" id="btn-ai">ğŸ§  AI</button>
  <button class="touch-btn" id="btn-robot">ğŸ¤– å‹•ä½œ</button>
  <button class="touch-btn" id="btn-camera">ğŸ“¹</button>
  <button class="touch-btn" id="btn-info">â„¹ï¸</button>
</div>

<script src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
const state = {
  cvReady: false,
  mlReady: false,
  mlEnabled: false,
  mlInFlight: false,
  lastObstacleScore: 100,
  robotEnabled: false,
  
  robotX: 140,
  robotY: 140,
  robotTheta: 0,
  robotVLin: 0,
  robotVAng: 0,
  targetVLin: 0,
  targetVAng: 0,
  
  gemmaLastAction: 'WAITING',
  gemmaNextAt: 0,
  gemmaThinking: false,
  
  // ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°æƒ…å ±
  steerValue: 0,  // -1..+1 (å·¦å±é™º=è² ã€å³å±é™º=æ­£)
  steerNextAt: 0
};

const video = document.getElementById('video');
const cvCanvas = document.getElementById('cv');

async function loadML() {
  if (window.tf && window.cocoSsd) return;
  
  console.log("Loading TensorFlow.js...");
  
  try {
    if (!window.tf) {
      await loadScript("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0");
    }
    if (!window.cocoSsd) {
      await loadScript("https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3");
    }
    state.model = await cocoSsd.load();
    state.mlReady = true;
    document.getElementById('gemma-status').textContent = 'æº–å‚™å®Œäº†';
    console.log("ML Model Ready");
  } catch (e) {
    console.error("ML Load Error:", e);
    document.getElementById('gemma-status').textContent = 'ã‚¨ãƒ©ãƒ¼';
  }
}

function loadScript(src) {
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = src;
    s.onload = resolve;
    s.onerror = reject;
    document.head.appendChild(s);
  });
}

const capCanvas = document.createElement('canvas');
const capCtx = capCanvas.getContext('2d', { willReadFrequently: true });

function runCV() {
  if (!state.cvReady || !video.videoWidth) return;
  
  capCanvas.width = video.videoWidth;
  capCanvas.height = video.videoHeight;
  capCtx.drawImage(video, 0, 0);
  
  let src = cv.matFromImageData(capCtx.getImageData(0, 0, video.videoWidth, video.videoHeight));
  let gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.Canny(gray, gray, 50, 100);
  cv.imshow(cvCanvas, gray);
  
  src.delete();
  gray.delete();
}

async function runML() {
  if (!state.mlEnabled || !state.mlReady || state.mlInFlight) return;
  
  state.mlInFlight = true;
  
  try {
    const preds = await state.model.detect(capCanvas);
    
    if (preds.length > 0) {
      let obj = preds.sort((a, b) => b.score - a.score)[0];
      state.lastObstacleScore = Math.max(5, Math.min(100, Math.round(obj.score * 100)));
    } else {
      state.lastObstacleScore = 100;
    }
    
    document.getElementById('obs-score').textContent = state.lastObstacleScore;
    
  } catch (e) {
    console.error("ML Error:", e);
  } finally {
    state.mlInFlight = false;
  }
}

// æ„Ÿæƒ…è¨ˆç®—ç”¨ã®ãƒ‡ãƒ¼ã‚¿
const steeringGradient = {
  columns: new Float32Array(9),
  bestSteer: 0
};

function calculateSteering() {
  // ç°¡æ˜“çš„ãªã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°è¨ˆç®—ï¼šãƒ©ãƒ³ãƒ€ãƒ ãªã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
  // å®Ÿéš›ã®ç”»åƒå‹¾é…ã®ä»£ã‚ã‚Šã«ã€å¹³æ»‘åŒ–ã•ã‚ŒãŸãƒ©ãƒ³ãƒ€ãƒ å€¤ã‚’ä½¿ç”¨
  const now = performance.now();
  
  if (now < state.steerNextAt) return;
  state.steerNextAt = now + 200; // 200ms ã”ã¨ã«æ›´æ–°
  
  // å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«å°ã•ãªãƒ©ãƒ³ãƒ€ãƒ å¤‰å‹•ã‚’åŠ ãˆã‚‹
  let sum = 0;
  for (let i = 0; i < steeringGradient.columns.length; i++) {
    // å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®å€¤ã«å°ã•ãªå¤‰å‹•ã‚’åŠ ãˆã‚‹ï¼ˆå¹³æ»‘åŒ–ï¼‰
    steeringGradient.columns[i] += (Math.random() - 0.5) * 0.3;
    steeringGradient.columns[i] = Math.max(0, Math.min(1, steeringGradient.columns[i]));
    sum += steeringGradient.columns[i];
  }
  
  // æœ€å°å±é™ºæ–¹å‘ã‚’æ¢ã™
  let minIdx = 0;
  let minVal = Infinity;
  for (let i = 0; i < steeringGradient.columns.length; i++) {
    if (steeringGradient.columns[i] < minVal) {
      minVal = steeringGradient.columns[i];
      minIdx = i;
    }
  }
  
  // -1..+1 ã«æ­£è¦åŒ–ï¼ˆä¸­å¤® = 4ï¼‰
  const mid = (steeringGradient.columns.length - 1) / 2;
  state.steerValue = (minIdx - mid) / mid;
  
  // UIæ›´æ–°
  let steerLabel = 'â†’ ä¸­ç«‹';
  if (state.steerValue < -0.3) {
    steerLabel = 'â† å·¦å±é™º';
  } else if (state.steerValue > 0.3) {
    steerLabel = 'å³å±é™º â†’';
  }
  document.getElementById('steer-display').textContent = steerLabel;
}

// æ„Ÿæƒ…çŠ¶æ…‹ã‚’æ›´æ–°ï¼ˆã‚»ãƒ³ã‚µãƒ¼å€¤ã«åŸºã¥ãï¼‰
function updateEmotionalState() {
  const now = performance.now();
  if (now < state.emotionNextUpdate) return;
  state.emotionNextUpdate = now + 300; // 300ms ã”ã¨ã«æ›´æ–°
  
  // æ„Ÿæƒ…åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯
  const distance = state.lastObstacleScore;
  const hasConfidence = distance > 60;
  const isAlert = distance < 40;
  const isConfused = state.gemmaThinking || state.mlInFlight;
  const isExcited = state.robotEnabled && state.robotVLin > 0.5;
  
  // æ„Ÿæƒ…ã®æ±ºå®š
  if (isConfused) {
    state.emotionState = 'confused';    // ğŸ¤” ç´«
    state.emotionIntensity = 0.8;
  } else if (isAlert) {
    state.emotionState = 'alert';       // âš ï¸ èµ¤
    state.emotionIntensity = Math.min(1, 1 - distance / 40);
  } else if (isExcited) {
    state.emotionState = 'excited';     // ğŸ˜„ é»„è‰²
    state.emotionIntensity = Math.min(1, state.robotVLin / 0.8);
  } else if (hasConfidence) {
    state.emotionState = 'confident';   // ğŸ˜Š ç·‘
    state.emotionIntensity = (distance - 60) / 40;
  } else {
    state.emotionState = 'neutral';     // ğŸ˜ é’
    state.emotionIntensity = 0.5;
  }
}

// æ„Ÿæƒ…ã«åŸºã¥ã„ã¦éŸ³ã‚’å†ç”Ÿ
function playEmotionSound() {
  // R2-D2 é¢¨ã®ã‚µã‚¦ãƒ³ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³
  const emotionSounds = {
    neutral: [
      { freq: 660, duration: 100 },   // ãƒ”
      { freq: 440, duration: 100 }    // ãƒ
    ],
    alert: [
      { freq: 880, duration: 80 },    // ãƒ”ãƒƒ
      { freq: 600, duration: 80 },    // ãƒãƒƒ
      { freq: 880, duration: 80 }     // ãƒ”ãƒƒ
    ],
    confident: [
      { freq: 330, duration: 150 },   // ã½ãƒ¼ã‚“ï¼ˆä½ï¼‰
      { freq: 550, duration: 150 }    // ã½ãƒ¼ã‚“ï¼ˆä¸­ï¼‰
    ],
    confused: [
      { freq: 440, duration: 50 },    // ãƒ”
      { freq: 330, duration: 50 },    // ãƒ
      { freq: 440, duration: 50 },    // ãƒ”
      { freq: 330, duration: 50 }     // ãƒ
    ],
    excited: [
      { freq: 550, duration: 80 },    // ãƒ”
      { freq: 770, duration: 80 },    // ãƒ
      { freq: 550, duration: 80 },    // ãƒ”
      { freq: 770, duration: 80 }     // ãƒ
    ]
  };
  
  const soundSequence = emotionSounds[state.emotionState] || emotionSounds.neutral;
  
  try {
    const audioContext = window.audioContext || new (window.AudioContext || window.webkitAudioContext)();
    window.audioContext = audioContext;
    
    let currentTime = audioContext.currentTime;
    
    soundSequence.forEach((sound) => {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = sound.freq;
      oscillator.type = 'sine';
      
      // ãƒ“ãƒ¼ãƒ—éŸ³ã®ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—ï¼ˆç´ æ—©ã„ç«‹ã¡ä¸ŠãŒã‚Šã¨è½ã¡è¾¼ã¿ï¼‰
      const duration = sound.duration / 1000;
      const volume = state.emotionIntensity * 0.15;
      
      gainNode.gain.setValueAtTime(volume, currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + duration * 0.8);
      gainNode.gain.setValueAtTime(0, currentTime + duration);
      
      oscillator.start(currentTime);
      oscillator.stop(currentTime + duration);
      
      currentTime += duration + 0.05; // éŸ³ã¨éŸ³ã®é–“ã«å°‘ã—é–“éš”
    });
  } catch (e) {
    console.log('Audio playback not available:', e);
  }
}

// æ„Ÿæƒ…è‰²ã‚’å–å¾—
function getEmotionColor() {
  const colors = {
    neutral: '#00AAFF',     // é’ - å¹³é™
    alert: '#FF3333',       // èµ¤ - è­¦æˆ’
    confident: '#00FF00',   // ç·‘ - ç¢ºä¿¡
    confused: '#BB00FF',    // ç´« - å›°æƒ‘
    excited: '#FFDD00'      // é»„ - èˆˆå¥®
  };
  return colors[state.emotionState] || '#00FF00';
}

// æ„Ÿæƒ…ãƒ©ãƒ™ãƒ«ã‚’å–å¾—
function getEmotionLabel() {
  const labels = {
    neutral: 'ğŸ˜ å¹³é™',
    alert: 'âš ï¸ è­¦æˆ’',
    confident: 'ğŸ˜Š ç¢ºä¿¡',
    confused: 'ğŸ¤” å›°æƒ‘',
    excited: 'ğŸ˜„ èˆˆå¥®'
  };
  return labels[state.emotionState] || '...';
}

// R2-D2ã‚¹ã‚¿ã‚¤ãƒ«ã®éŸ³å£°åŠ¹æœï¼ˆã‚¤ãƒ™ãƒ³ãƒˆæ™‚ï¼‰
function playR2D2Sound(type) {
  const soundPatterns = {
    startup: [
      { freq: 400, duration: 200 },
      { freq: 600, duration: 150 },
      { freq: 800, duration: 200 }
    ],
    success: [
      { freq: 550, duration: 100 },
      { freq: 770, duration: 100 },
      { freq: 550, duration: 100 }
    ],
    error: [
      { freq: 700, duration: 100 },
      { freq: 400, duration: 100 },
      { freq: 700, duration: 100 },
      { freq: 400, duration: 100 }
    ],
    movement: [
      { freq: 500, duration: 60 },
      { freq: 700, duration: 60 }
    ]
  };
  
  const pattern = soundPatterns[type] || soundPatterns.movement;
  
  try {
    const audioContext = window.audioContext || new (window.AudioContext || window.webkitAudioContext)();
    window.audioContext = audioContext;
    
    let currentTime = audioContext.currentTime;
    
    pattern.forEach((sound) => {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = sound.freq;
      oscillator.type = 'sine';
      
      const duration = sound.duration / 1000;
      gainNode.gain.setValueAtTime(0.2, currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + duration * 0.7);
      gainNode.gain.setValueAtTime(0, currentTime + duration);
      
      oscillator.start(currentTime);
      oscillator.stop(currentTime + duration);
      
      currentTime += duration + 0.03;
    });
  } catch (e) {
    console.log('Audio not available');
  }
}

async function askGemma(now) {
  if (!state.robotEnabled || now < state.gemmaNextAt || state.gemmaThinking) return;
  
  state.gemmaThinking = true;
  state.gemmaNextAt = now + 2500;
  document.getElementById('gemma-status').textContent = 'æ€è€ƒä¸­...';
  
  const distance = state.lastObstacleScore;
  console.log("Distance:", distance);
  
  try {
    const res = await fetch('https://kgninja-functiongemmabotdemo-docker.hf.space/decide', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        front_distance: distance,
        speed: state.robotVLin,
        steer: state.steerValue  // ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°æƒ…å ±ã‚’é€ä¿¡
      })
    });
    
    const json = await res.json();
    console.log("API Response:", json);
    
    let action = null;
    
    if (json.data && json.data[0]) {
      const match = json.data[0].match(/\{.*\}/s);
      if (match) {
        const d = JSON.parse(match[0]);
        action = (d.action || '').toLowerCase();
        console.log("Parsed action:", action);
      }
    }
    
    // APIãŒç„¡åŠ¹ãªå¿œç­”ã®å ´åˆã€è·é›¢ãƒ™ãƒ¼ã‚¹ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    if (!action) {
      console.warn("âš ï¸ API invalid, using fallback logic");
      if (distance < 30) {
        action = Math.random() > 0.5 ? 'turn_left' : 'turn_right';
      } else if (distance < 60) {
        const actions = ['move_forward', 'turn_left', 'turn_right'];
        action = actions[Math.floor(Math.random() * 3)];
      } else {
        action = 'move_forward';
      }
      console.log("Fallback action:", action);
    }
    
    state.gemmaLastAction = action.toUpperCase().replace('_', ' ');
    document.getElementById('last-decision').textContent = state.gemmaLastAction;
    document.getElementById('gemma-status').textContent = 'å®Œäº† âœ“';
    
    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«åŸºã¥ã„ã¦ç›®æ¨™é€Ÿåº¦ã‚’è¨­å®š
    if (action === 'move_forward') {
      state.targetVLin = 0.8;
      state.targetVAng = 0;
      console.log("â†’ FORWARD");
    } else if (action === 'turn_left') {
      state.targetVLin = 0.3;
      state.targetVAng = -2.0;  // å·¦å›è»¢
      console.log("â†’ LEFT");
    } else if (action === 'turn_right') {
      state.targetVLin = 0.3;
      state.targetVAng = 2.0;   // å³å›è»¢
      console.log("â†’ RIGHT");
    } else {
      state.targetVLin = 0;
      state.targetVAng = 0;
      console.log("â†’ STOP");
    }
    
  } catch (e) {
    console.error("Gemma API Error:", e);
    document.getElementById('gemma-status').textContent = 'APIå¤±æ•—';
    state.targetVLin = 0;
    state.targetVAng = 0;
  } finally {
    state.gemmaThinking = false;
  }
}

function animate(now) {
  if (!state.cvReady && video.videoWidth > 0) {
    cvCanvas.width = 320;
    cvCanvas.height = 240;
    state.cvReady = true;
  }
  
  runCV();
  runML();
  calculateSteering();  // ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°è¨ˆç®—ã‚’è¿½åŠ 
  updateEmotionalState();  // æ„Ÿæƒ…çŠ¶æ…‹ã‚’æ›´æ–°
  
  if (state.mlEnabled) {
    askGemma(now);
  }
  
  if (state.robotEnabled) {
    state.robotVLin += (state.targetVLin - state.robotVLin) * 0.15;
    state.robotVAng += (state.targetVAng - state.robotVAng) * 0.15;
    
    state.robotTheta += state.robotVAng * 0.016;
    state.robotX += Math.cos(state.robotTheta) * state.robotVLin * 3;
    state.robotY += Math.sin(state.robotTheta) * state.robotVLin * 3;
    
    state.robotX = Math.max(15, Math.min(265, state.robotX));
    state.robotY = Math.max(15, Math.min(265, state.robotY));
  }
  
  document.getElementById('speed-display').textContent = state.robotVLin.toFixed(2);
  
  // UIæ›´æ–°
  document.getElementById('emotion-display').textContent = getEmotionLabel();
  
  drawSimulator();
  drawSteeringGauge();
  drawEmotionGauge();
  
  // å®šæœŸçš„ã«æ„Ÿæƒ…éŸ³ã‚’å†ç”Ÿï¼ˆ1ç§’ã”ã¨ï¼‰
  if (now % 1000 < 50) {
    playEmotionSound();
  }
  
  requestAnimationFrame(animate);
}

function drawSteeringGauge() {
  const canvas = document.getElementById('steer-gauge');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;
  
  // èƒŒæ™¯
  ctx.fillStyle = 'rgba(0, 15, 0, 0.95)';
  ctx.fillRect(0, 0, w, h);
  
  // ã‚°ãƒªãƒƒãƒ‰ãƒ©ã‚¤ãƒ³ã¨å±é™ºåº¦ãƒãƒ¼
  const sections = 9;
  const secWidth = w / sections;
  
  for (let i = 0; i < sections; i++) {
    const x = i * secWidth;
    
    // ã‚»ã‚¯ã‚·ãƒ§ãƒ³èƒŒæ™¯
    const hazardLevel = steeringGradient.columns[i];
    const a = 0.15 + 0.65 * hazardLevel;
    ctx.fillStyle = `rgba(255, 255, 255, ${a})`;
    ctx.fillRect(x + 1, 4, secWidth - 2, h - 8);
    
    // ã‚»ã‚¯ã‚·ãƒ§ãƒ³å¢ƒç•Œç·š
    ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x + 0.5, 2);
    ctx.lineTo(x + 0.5, h - 2);
    ctx.stroke();
  }
  
  // å®‰å…¨ãªæ–¹å‘ã‚’ç¤ºã™ç™½ã„æŒ‡æ¨™ç·š
  const steerX = ((state.steerValue + 1) / 2) * w;
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(steerX, 2);
  ctx.lineTo(steerX, h - 2);
  ctx.stroke();
  
  // ãƒ©ãƒ™ãƒ«
  ctx.font = '10px monospace';
  ctx.fillStyle = '#0f0';
  ctx.textAlign = 'left';
  ctx.fillText('å·¦', 5, 14);
  ctx.textAlign = 'right';
  ctx.fillText('å³', w - 5, 14);
  ctx.textAlign = 'center';
  ctx.fillText('å±é™ºåº¦ãƒãƒƒãƒ—', w / 2, 14);
}

function drawEmotionGauge() {
  const canvas = document.getElementById('emotion-gauge');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const w = canvas.width;
  const h = canvas.height;
  
  // èƒŒæ™¯
  ctx.fillStyle = 'rgba(0, 15, 0, 0.95)';
  ctx.fillRect(0, 0, w, h);
  
  // æ„Ÿæƒ…è‰²ã®èƒŒæ™¯
  const emotionColor = getEmotionColor();
  ctx.fillStyle = emotionColor + '44';  // åŠé€æ˜
  ctx.fillRect(0, 0, w, h);
  
  // æ„Ÿæƒ…ã‚¤ãƒ³ãƒ†ãƒ³ã‚·ãƒ†ã‚£ã‚’ç¤ºã™çŸ©å½¢
  const barWidth = w * state.emotionIntensity;
  ctx.fillStyle = emotionColor;
  ctx.fillRect(0, 0, barWidth, h);
  
  // æ ç·š
  ctx.strokeStyle = emotionColor;
  ctx.lineWidth = 2;
  ctx.strokeRect(0, 0, w, h);
  
  // ãƒ©ãƒ™ãƒ«
  ctx.font = 'bold 14px monospace';
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.fillText(getEmotionLabel(), w / 2, h / 2 + 5);
}

function drawSimulator() {
  const canvas = document.getElementById('robot-sim');
  const ctx = canvas.getContext('2d');
  
  const w = canvas.width;
  const h = canvas.height;
  
  ctx.fillStyle = 'rgba(0, 15, 0, 0.95)';
  ctx.fillRect(0, 0, w, h);
  
  ctx.strokeStyle = 'rgba(0, 255, 0, 0.1)';
  ctx.lineWidth = 1;
  const gridSize = Math.floor(w / 10);
  for (let i = 0; i <= w; i += gridSize) {
    ctx.beginPath();
    ctx.moveTo(i, 0);
    ctx.lineTo(i, h);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, i);
    ctx.lineTo(w, i);
    ctx.stroke();
  }
  
  ctx.font = `bold ${Math.max(10, w / 20)}px monospace`;
  ctx.fillStyle = '#0f0';
  ctx.fillText('AI: ' + state.gemmaLastAction, w * 0.05, w * 0.1);
  
  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fillRect(w * 0.05, w * 0.15, w * 0.35, w * 0.08);
  ctx.strokeStyle = '#0f0';
  ctx.strokeRect(w * 0.05, w * 0.15, w * 0.35, w * 0.08);
  
  const fillWidth = (state.lastObstacleScore / 100) * (w * 0.35);
  ctx.fillStyle = state.lastObstacleScore > 50 ? '#0f0' : state.lastObstacleScore > 20 ? '#ff0' : '#f00';
  ctx.fillRect(w * 0.05, w * 0.15, fillWidth, w * 0.08);
  
  ctx.font = `${Math.max(8, w / 25)}px monospace`;
  ctx.fillStyle = '#0f0';
  ctx.fillText('è·é›¢: ' + state.lastObstacleScore, w * 0.07, w * 0.26);
  
  // ã‚¹ã‚±ãƒ¼ãƒ«è¨ˆç®—ï¼ˆã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã«å¿œã˜ãŸåº§æ¨™å¤‰æ›ï¼‰
  const scale = w / 280;
  
  ctx.save();
  ctx.translate(state.robotX * scale, state.robotY * scale);
  ctx.rotate(state.robotTheta);
  
  ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
  ctx.beginPath();
  ctx.arc(0, 0, 12 * scale, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 2 * scale;
  ctx.stroke();
  
  ctx.fillStyle = '#0f0';
  ctx.beginPath();
  ctx.moveTo(0, -12 * scale);
  ctx.lineTo(-6 * scale, 6 * scale);
  ctx.lineTo(6 * scale, 6 * scale);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
  
  ctx.font = `${Math.max(8, w / 28)}px monospace`;
  ctx.fillStyle = 'rgba(0, 255, 0, 0.6)';
  ctx.fillText('é€Ÿåº¦: ' + state.robotVLin.toFixed(2), w * 0.05, h - w * 0.05);
  ctx.fillText('è§’é€Ÿåº¦: ' + state.robotVAng.toFixed(1), w * 0.5, h - w * 0.05);
  
  if (!state.robotEnabled) {
    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
    ctx.font = `bold ${Math.max(12, w / 15)}px monospace`;
    ctx.fillText('STOPPED', w * 0.25, h * 0.5);
  }
}

window.addEventListener('keydown', e => {
  if (e.code === 'KeyM') {
    state.mlEnabled = !state.mlEnabled;
    if (state.mlEnabled) {
      loadML();
      document.getElementById('gemma-status').textContent = 'èª­ã¿è¾¼ã¿ä¸­...';
    } else {
      document.getElementById('gemma-status').textContent = 'ç„¡åŠ¹';
      document.getElementById('last-decision').textContent = '-';
    }
  }
  
  if (e.code === 'KeyR') {
    state.robotEnabled = !state.robotEnabled;
    const modeEl = document.getElementById('robot-mode');
    modeEl.textContent = state.robotEnabled ? 'ç¨¼åƒä¸­' : 'åœæ­¢ä¸­';
    modeEl.style.color = state.robotEnabled ? '#0f0' : '#f00';
    
    if (!state.robotEnabled) {
      state.targetVLin = 0;
      state.targetVAng = 0;
      state.robotVLin = 0;
      state.robotVAng = 0;
    }
  }
});

// ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ç”¨ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
document.getElementById('btn-ai')?.addEventListener('click', () => {
  state.mlEnabled = !state.mlEnabled;
  if (state.mlEnabled) {
    loadML();
    document.getElementById('gemma-status').textContent = 'èª­ã¿è¾¼ã¿ä¸­...';
  } else {
    document.getElementById('gemma-status').textContent = 'ç„¡åŠ¹';
  }
});

document.getElementById('btn-robot')?.addEventListener('click', () => {
  state.robotEnabled = !state.robotEnabled;
  const modeEl = document.getElementById('robot-mode');
  modeEl.textContent = state.robotEnabled ? 'ç¨¼åƒä¸­' : 'åœæ­¢ä¸­';
  modeEl.style.color = state.robotEnabled ? '#0f0' : '#f00';
  
  if (!state.robotEnabled) {
    state.targetVLin = 0;
    state.targetVAng = 0;
    state.robotVLin = 0;
    state.robotVAng = 0;
  }
});

document.getElementById('btn-camera')?.addEventListener('click', () => {
  state.debugEdges = !state.debugEdges;
});

let showInfo = false;
document.getElementById('btn-info')?.addEventListener('click', () => {
  showInfo = !showInfo;
  const ui = document.getElementById('ui');
  ui.style.display = showInfo ? 'block' : 'block';
});

cv['onRuntimeInitialized'] = () => {
  navigator.mediaDevices.getUserMedia({ video: true }).then(s => {
    video.srcObject = s;
    video.play();
    
    // iPhone SE ãªã©ã®å°ã•ã„ç”»é¢ã«å¯¾å¿œ
    adjustSimulatorSize();
    
    requestAnimationFrame(animate);
    console.log("System Ready - Press M to enable AI, R to enable Robot");
  });
};

function adjustSimulatorSize() {
  const simCanvas = document.getElementById('robot-sim');
  const isMobile = window.innerWidth < 768;
  
  if (!simCanvas) return;
  
  if (isMobile) {
    // ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³å¯¾å¿œ
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;
    
    // ã‚«ãƒ¡ãƒ©: 60%, UI: 25%, ãƒœã‚¿ãƒ³: 15%
    const availableHeight = screenHeight * 0.25;
    const availableWidth = screenWidth;
    
    // æ­£æ–¹å½¢ã‚’ç¶­æŒã—ãªãŒã‚‰ã€åˆ©ç”¨å¯èƒ½ã‚¹ãƒšãƒ¼ã‚¹ã«åã‚ã‚‹
    const maxSize = Math.min(availableWidth * 0.4, availableHeight * 0.9);
    
    simCanvas.width = Math.floor(maxSize);
    simCanvas.height = Math.floor(maxSize);
    simCanvas.style.width = maxSize + 'px';
    simCanvas.style.height = maxSize + 'px';
    
    console.log(`Simulator size: ${maxSize}px (Mobile)`);
  } else {
    // PC/ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆå¯¾å¿œ
    simCanvas.width = 280;
    simCanvas.height = 280;
    simCanvas.style.width = '280px';
    simCanvas.style.height = '280px';
  }
}

// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºæ™‚ã«ã‚‚èª¿æ•´
window.addEventListener('resize', () => {
  adjustSimulatorSize();
});
</script>

</body>
</html>
